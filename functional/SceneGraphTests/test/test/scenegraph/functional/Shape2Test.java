/*
 * The GNU General Public License (GPL)
 *
 * Version 2, June 1991
 *
 * Copyright (C) 1989, 1991 Free Software Foundation, Inc.
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 * Everyone is permitted to copy and distribute verbatim copies of this license
 * document, but changing it is not allowed.
 *
 * Preamble
 *
 * The licenses for most software are designed to take away your freedom to share
 * and change it.  By contrast, the GNU General Public License is intended to
 * guarantee your freedom to share and change free software--to make sure the
 * software is free for all its users.  This General Public License applies to
 * most of the Free Software Foundation's software and to any other program whose
 * authors commit to using it.  (Some other Free Software Foundation software is
 * covered by the GNU Library General Public License instead.) You can apply it to
 * your programs, too.
 *
 * When we speak of free software, we are referring to freedom, not price.  Our
 * General Public Licenses are designed to make sure that you have the freedom to
 * distribute copies of free software (and charge for this service if you wish),
 * that you receive source code or can get it if you want it, that you can change
 * the software or use pieces of it in new free programs; and that you know you
 * can do these things.
 *
 * To protect your rights, we need to make restrictions that forbid anyone to deny
 * you these rights or to ask you to surrender the rights.  These restrictions
 * translate to certain responsibilities for you if you distribute copies of the
 * software, or if you modify it.
 *
 * For example, if you distribute copies of such a program, whether gratis or for
 * a fee, you must give the recipients all the rights that you have.  You must
 * make sure that they, too, receive or can get the source code.  And you must
 * show them these terms so they know their rights.
 *
 * We protect your rights with two steps: (1) copyright the software, and (2)
 * offer you this license which gives you legal permission to copy, distribute
 * and/or modify the software.
 *
 * Also, for each author's protection and ours, we want to make certain that
 * everyone understands that there is no warranty for this free software.  If the
 * software is modified by someone else and passed on, we want its recipients to
 * know that what they have is not the original, so that any problems introduced
 * by others will not reflect on the original authors' reputations.
 *
 * Finally, any free program is threatened constantly by software patents.  We
 * wish to avoid the danger that redistributors of a free program will
 * individually obtain patent licenses, in effect making the program proprietary.
 * To prevent this, we have made it clear that any patent must be licensed for
 * everyone's free use or not licensed at all.
 *
 * The precise terms and conditions for copying, distribution and modification
 * follow.
 *
 * TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
 *
 * 0. This License applies to any program or other work which contains a notice
 * placed by the copyright holder saying it may be distributed under the terms of
 * this General Public License.  The "Program", below, refers to any such program
 * or work, and a "work based on the Program" means either the Program or any
 * derivative work under copyright law: that is to say, a work containing the
 * Program or a portion of it, either verbatim or with modifications and/or
 * translated into another language.  (Hereinafter, translation is included
 * without limitation in the term "modification".) Each licensee is addressed as
 * "you".
 *
 * Activities other than copying, distribution and modification are not covered by
 * this License; they are outside its scope.  The act of running the Program is
 * not restricted, and the output from the Program is covered only if its contents
 * constitute a work based on the Program (independent of having been made by
 * running the Program).  Whether that is true depends on what the Program does.
 *
 * 1. You may copy and distribute verbatim copies of the Program's source code as
 * you receive it, in any medium, provided that you conspicuously and
 * appropriately publish on each copy an appropriate copyright notice and
 * disclaimer of warranty; keep intact all the notices that refer to this License
 * and to the absence of any warranty; and give any other recipients of the
 * Program a copy of this License along with the Program.
 *
 * You may charge a fee for the physical act of transferring a copy, and you may
 * at your option offer warranty protection in exchange for a fee.
 *
 * 2. You may modify your copy or copies of the Program or any portion of it, thus
 * forming a work based on the Program, and copy and distribute such modifications
 * or work under the terms of Section 1 above, provided that you also meet all of
 * these conditions:
 *
 *     a) You must cause the modified files to carry prominent notices stating
 *     that you changed the files and the date of any change.
 *
 *     b) You must cause any work that you distribute or publish, that in whole or
 *     in part contains or is derived from the Program or any part thereof, to be
 *     licensed as a whole at no charge to all third parties under the terms of
 *     this License.
 *
 *     c) If the modified program normally reads commands interactively when run,
 *     you must cause it, when started running for such interactive use in the
 *     most ordinary way, to print or display an announcement including an
 *     appropriate copyright notice and a notice that there is no warranty (or
 *     else, saying that you provide a warranty) and that users may redistribute
 *     the program under these conditions, and telling the user how to view a copy
 *     of this License.  (Exception: if the Program itself is interactive but does
 *     not normally print such an announcement, your work based on the Program is
 *     not required to print an announcement.)
 *
 * These requirements apply to the modified work as a whole.  If identifiable
 * sections of that work are not derived from the Program, and can be reasonably
 * considered independent and separate works in themselves, then this License, and
 * its terms, do not apply to those sections when you distribute them as separate
 * works.  But when you distribute the same sections as part of a whole which is a
 * work based on the Program, the distribution of the whole must be on the terms
 * of this License, whose permissions for other licensees extend to the entire
 * whole, and thus to each and every part regardless of who wrote it.
 *
 * Thus, it is not the intent of this section to claim rights or contest your
 * rights to work written entirely by you; rather, the intent is to exercise the
 * right to control the distribution of derivative or collective works based on
 * the Program.
 *
 * In addition, mere aggregation of another work not based on the Program with the
 * Program (or with a work based on the Program) on a volume of a storage or
 * distribution medium does not bring the other work under the scope of this
 * License.
 *
 * 3. You may copy and distribute the Program (or a work based on it, under
 * Section 2) in object code or executable form under the terms of Sections 1 and
 * 2 above provided that you also do one of the following:
 *
 *     a) Accompany it with the complete corresponding machine-readable source
 *     code, which must be distributed under the terms of Sections 1 and 2 above
 *     on a medium customarily used for software interchange; or,
 *
 *     b) Accompany it with a written offer, valid for at least three years, to
 *     give any third party, for a charge no more than your cost of physically
 *     performing source distribution, a complete machine-readable copy of the
 *     corresponding source code, to be distributed under the terms of Sections 1
 *     and 2 above on a medium customarily used for software interchange; or,
 *
 *     c) Accompany it with the information you received as to the offer to
 *     distribute corresponding source code.  (This alternative is allowed only
 *     for noncommercial distribution and only if you received the program in
 *     object code or executable form with such an offer, in accord with
 *     Subsection b above.)
 *
 * The source code for a work means the preferred form of the work for making
 * modifications to it.  For an executable work, complete source code means all
 * the source code for all modules it contains, plus any associated interface
 * definition files, plus the scripts used to control compilation and installation
 * of the executable.  However, as a special exception, the source code
 * distributed need not include anything that is normally distributed (in either
 * source or binary form) with the major components (compiler, kernel, and so on)
 * of the operating system on which the executable runs, unless that component
 * itself accompanies the executable.
 *
 * If distribution of executable or object code is made by offering access to copy
 * from a designated place, then offering equivalent access to copy the source
 * code from the same place counts as distribution of the source code, even though
 * third parties are not compelled to copy the source along with the object code.
 *
 * 4. You may not copy, modify, sublicense, or distribute the Program except as
 * expressly provided under this License.  Any attempt otherwise to copy, modify,
 * sublicense or distribute the Program is void, and will automatically terminate
 * your rights under this License.  However, parties who have received copies, or
 * rights, from you under this License will not have their licenses terminated so
 * long as such parties remain in full compliance.
 *
 * 5. You are not required to accept this License, since you have not signed it.
 * However, nothing else grants you permission to modify or distribute the Program
 * or its derivative works.  These actions are prohibited by law if you do not
 * accept this License.  Therefore, by modifying or distributing the Program (or
 * any work based on the Program), you indicate your acceptance of this License to
 * do so, and all its terms and conditions for copying, distributing or modifying
 * the Program or works based on it.
 *
 * 6. Each time you redistribute the Program (or any work based on the Program),
 * the recipient automatically receives a license from the original licensor to
 * copy, distribute or modify the Program subject to these terms and conditions.
 * You may not impose any further restrictions on the recipients' exercise of the
 * rights granted herein.  You are not responsible for enforcing compliance by
 * third parties to this License.
 *
 * 7. If, as a consequence of a court judgment or allegation of patent
 * infringement or for any other reason (not limited to patent issues), conditions
 * are imposed on you (whether by court order, agreement or otherwise) that
 * contradict the conditions of this License, they do not excuse you from the
 * conditions of this License.  If you cannot distribute so as to satisfy
 * simultaneously your obligations under this License and any other pertinent
 * obligations, then as a consequence you may not distribute the Program at all.
 * For example, if a patent license would not permit royalty-free redistribution
 * of the Program by all those who receive copies directly or indirectly through
 * you, then the only way you could satisfy both it and this License would be to
 * refrain entirely from distribution of the Program.
 *
 * If any portion of this section is held invalid or unenforceable under any
 * particular circumstance, the balance of the section is intended to apply and
 * the section as a whole is intended to apply in other circumstances.
 *
 * It is not the purpose of this section to induce you to infringe any patents or
 * other property right claims or to contest validity of any such claims; this
 * section has the sole purpose of protecting the integrity of the free software
 * distribution system, which is implemented by public license practices.  Many
 * people have made generous contributions to the wide range of software
 * distributed through that system in reliance on consistent application of that
 * system; it is up to the author/donor to decide if he or she is willing to
 * distribute software through any other system and a licensee cannot impose that
 * choice.
 *
 * This section is intended to make thoroughly clear what is believed to be a
 * consequence of the rest of this License.
 *
 * 8. If the distribution and/or use of the Program is restricted in certain
 * countries either by patents or by copyrighted interfaces, the original
 * copyright holder who places the Program under this License may add an explicit
 * geographical distribution limitation excluding those countries, so that
 * distribution is permitted only in or among countries not thus excluded.  In
 * such case, this License incorporates the limitation as if written in the body
 * of this License.
 *
 * 9. The Free Software Foundation may publish revised and/or new versions of the
 * General Public License from time to time.  Such new versions will be similar in
 * spirit to the present version, but may differ in detail to address new problems
 * or concerns.
 *
 * Each version is given a distinguishing version number.  If the Program
 * specifies a version number of this License which applies to it and "any later
 * version", you have the option of following the terms and conditions either of
 * that version or of any later version published by the Free Software Foundation.
 * If the Program does not specify a version number of this License, you may
 * choose any version ever published by the Free Software Foundation.
 *
 * 10. If you wish to incorporate parts of the Program into other free programs
 * whose distribution conditions are different, write to the author to ask for
 * permission.  For software which is copyrighted by the Free Software Foundation,
 * write to the Free Software Foundation; we sometimes make exceptions for this.
 * Our decision will be guided by the two goals of preserving the free status of
 * all derivatives of our free software and of promoting the sharing and reuse of
 * software generally.
 *
 * NO WARRANTY
 *
 * 11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR
 * THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN OTHERWISE
 * STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE
 * PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND
 * PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE,
 * YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
 *
 * 12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL
 * ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE
 * PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
 * GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR
 * INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA
 * BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
 * FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER
 * OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
 *
 * END OF TERMS AND CONDITIONS
 *
 * How to Apply These Terms to Your New Programs
 *
 * If you develop a new program, and you want it to be of the greatest possible
 * use to the public, the best way to achieve this is to make it free software
 * which everyone can redistribute and change under these terms.
 *
 * To do so, attach the following notices to the program.  It is safest to attach
 * them to the start of each source file to most effectively convey the exclusion
 * of warranty; and each file should have at least the "copyright" line and a
 * pointer to where the full notice is found.
 *
 *     One line to give the program's name and a brief idea of what it does.
 *
 *     Copyright (C) <year> <name of author>
 *
 *     This program is free software; you can redistribute it and/or modify it
 *     under the terms of the GNU General Public License as published by the Free
 *     Software Foundation; either version 2 of the License, or (at your option)
 *     any later version.
 *
 *     This program is distributed in the hope that it will be useful, but WITHOUT
 *     ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 *     FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 *     more details.
 *
 *     You should have received a copy of the GNU General Public License along
 *     with this program; if not, write to the Free Software Foundation, Inc., 59
 *     Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 * Also add information on how to contact you by electronic and paper mail.
 *
 * If the program is interactive, make it output a short notice like this when it
 * starts in an interactive mode:
 *
 *     Gnomovision version 69, Copyright (C) year name of author Gnomovision comes
 *     with ABSOLUTELY NO WARRANTY; for details type 'show w'.  This is free
 *     software, and you are welcome to redistribute it under certain conditions;
 *     type 'show c' for details.
 *
 * The hypothetical commands 'show w' and 'show c' should show the appropriate
 * parts of the General Public License.  Of course, the commands you use may be
 * called something other than 'show w' and 'show c'; they could even be
 * mouse-clicks or menu items--whatever suits your program.
 *
 * You should also get your employer (if you work as a programmer) or your school,
 * if any, to sign a "copyright disclaimer" for the program, if necessary.  Here
 * is a sample; alter the names:
 *
 *     Yoyodyne, Inc., hereby disclaims all copyright interest in the program
 *     'Gnomovision' (which makes passes at compilers) written by James Hacker.
 *
 *     signature of Ty Coon, 1 April 1989
 *
 *     Ty Coon, President of Vice
 *
 * This General Public License does not permit incorporating your program into
 * proprietary programs.  If your program is a subroutine library, you may
 * consider it more useful to permit linking proprietary applications with the
 * library.  If this is what you want to do, use the GNU Library General Public
 * License instead of this License.
 *
 *
 * "CLASSPATH" EXCEPTION TO THE GPL
 *
 * Certain source files distributed by Oracle America and/or its affiliates are
 * subject to the following clarification and special exception to the GPL, but
 * only where Oracle has expressly included in the particular source file's header
 * the words "Oracle designates this particular file as subject to the "Classpath"
 * exception as provided by Oracle in the LICENSE file that accompanied this code."
 *
 *     Linking this library statically or dynamically with other modules is making
 *     a combined work based on this library.  Thus, the terms and conditions of
 *     the GNU General Public License cover the whole combination.
 *
 *     As a special exception, the copyright holders of this library give you
 *     permission to link this library with independent modules to produce an
 *     executable, regardless of the license terms of these independent modules,
 *     and to copy and distribute the resulting executable under terms of your
 *     choice, provided that you also meet, for each linked independent module,
 *     the terms and conditions of the license of that module.  An independent
 *     module is a module which is not derived from or based on this library.  If
 *     you modify this library, you may extend this exception to your version of
 *     the library, but you are not obligated to do so.  If you do not wish to do
 *     so, delete this exception statement from your version.
 */
package test.scenegraph.functional;

import org.junit.Test;
import org.junit.BeforeClass;
import test.scenegraph.app.Effects;

import static test.scenegraph.app.Shapes2App.Pages.*;
import test.javaclient.shared.TestBase;
import test.scenegraph.app.Shapes2App;


/**
 * This test uses {@link test.scenegraph.app.ShapesApp} to verify drawing of
 * Shapes using <code>Strokes</code> and <code>Paints</code> modificators.
 *
 * Each test opens a page at app with specified shapes being drawn with
 * different settings ({@link test.scenegraph.app.Effects}). Test validates
 * presence of each Shape on Scene and compares results with screenshot.
 *
 * @see test.scenegraph.app.ShapesApp
 * @see test.scenegraph.app.Effects
 * @author Sergey Grinev
 */
public class Shape2Test extends TestBase {

    /**
     * Runs UI.
     */
    //@RunUI
    @BeforeClass
    public static void runUI() {
        Shapes2App.main(null);
    }

    public static void exitUI() {
    }

/**
 * test Circle
 * with setFill(Color.BISQUE)
 */
    @Test
    public void Circle_FILL() throws InterruptedException {
        testCommon(Circle.name(), Effects.FILL.name());
    }

    /**
 * test Circle
 * 
 */
    @Test
    public void Circle_INTERSECT() throws InterruptedException {
        testCommon(Circle.name(), Effects.INTERSECT.name());
    }
    
       /**
 * test Circle
 * 
 */
    @Test
    public void Circle_SUBTRACT() throws InterruptedException {
        testCommon(Circle.name(), Effects.SUBTRACT.name());
    }
       /**
 * test Circle
 * 
 */
    @Test
    public void Circle_SUBTRACT_WT_DASH() throws InterruptedException {
        testCommon(Circle.name(), Effects.SUB_WT_DASH.name());
    }
       /**
 * test Circle
 * 
 */
    @Test
    public void Circle_UNION() throws InterruptedException {
        testCommon(Circle.name(), Effects.UNION.name());
    }
       /**
 * test Circle
 * 
 */
    @Test
    public void Circle_UNION_WT_TRANSFORM() throws InterruptedException {
        testCommon(Circle.name(), Effects.UN_WT_TRANSF.name());
    }
    
        /**
 * test Arc
 * 
 */
    @Test
    public void Arc_INTERSECT() throws InterruptedException {
        testCommon(Arc.name(), Effects.INTERSECT.name());
    }
    
       /**
 * test Arc
 * 
 */
    @Test
    public void Arc_SUBTRACT() throws InterruptedException {
        testCommon(Arc.name(), Effects.SUBTRACT.name());
    }
       /**
 * test Arc
 * 
 */
    @Test
    public void Arc_SUBTRACT_WT_DASH() throws InterruptedException {
        testCommon(Arc.name(), Effects.SUB_WT_DASH.name());
    }
       /**
 * test Arc
 * 
 */
    @Test
    public void Arc_UNION() throws InterruptedException {
        testCommon(Arc.name(), Effects.UNION.name());
    }
       /**
 * test Arc
 */
    @Test
    public void Arc_UNION_WT_TRANSFORM() throws InterruptedException {
        testCommon(Arc.name(), Effects.UN_WT_TRANSF.name());
    }   
    
            /**
 * test CubicCurve
 * 
 */
    @Test
    public void CubicCurve_INTERSECT() throws InterruptedException {
        testCommon(CubicCurve.name(), Effects.INTERSECT.name());
    }
    
       /**
 * test CubicCurve
 * 
 */
    @Test
    public void CubicCurve_SUBTRACT() throws InterruptedException {
        testCommon(CubicCurve.name(), Effects.SUBTRACT.name());
    }
       /**
 * test CubicCurve
 * 
 */
    @Test
    public void CubicCurve_SUBTRACT_WT_DASH() throws InterruptedException {
        testCommon(CubicCurve.name(), Effects.SUB_WT_DASH.name());
    }
       /**
 * test CubicCurve
 * 
 */
    @Test
    public void CubicCurve_UNION() throws InterruptedException {
        testCommon(CubicCurve.name(), Effects.UNION.name());
    }
       /**
 * test CubicCurve
 */
    @Test
    public void CubicCurve_UNION_WT_TRANSFORM() throws InterruptedException {
        testCommon(CubicCurve.name(), Effects.UN_WT_TRANSF.name());
    }
    
       
            /**
 * test Ellipse
 * 
 */
    @Test
    public void Ellipse_INTERSECT() throws InterruptedException {
        testCommon(Ellipse.name(), Effects.INTERSECT.name());
    }
    
       /**
 * test Ellipse
 * 
 */
    @Test
    public void Ellipse_SUBTRACT() throws InterruptedException {
        testCommon(Ellipse.name(), Effects.SUBTRACT.name());
    }
       /**
 * test Ellipse
 * 
 */
    @Test
    public void Ellipse_SUBTRACT_WT_DASH() throws InterruptedException {
        testCommon(Ellipse.name(), Effects.SUB_WT_DASH.name());
    }
       /**
 * test Ellipse
 * 
 */
    @Test
    public void Ellipse_UNION() throws InterruptedException {
        testCommon(Ellipse.name(), Effects.UNION.name());
    }
       /**
 * test Ellipse
 */
    @Test
    public void Ellipse_UNION_WT_TRANSFORM() throws InterruptedException {
        testCommon(Ellipse.name(), Effects.UN_WT_TRANSF.name());
    }
    
              /**
 * test Line
 * 
 */
    @Test
    public void Line_INTERSECT() throws InterruptedException {
        testCommon(Line.name(), Effects.INTERSECT.name());
    }
    
       /**
 * test Line
 * 
 */
    @Test
    public void Line_SUBTRACT() throws InterruptedException {
        testCommon(Line.name(), Effects.SUBTRACT.name());
    }
       /**
 * test Line
 * 
 */
    @Test
    public void Line_SUBTRACT_WT_DASH() throws InterruptedException {
        testCommon(Line.name(), Effects.SUB_WT_DASH.name());
    }
       /**
 * test Line
 * 
 */
    @Test
    public void Line_UNION() throws InterruptedException {
        testCommon(Ellipse.name(), Effects.UNION.name());
    }
       /**
 * test Line
 */
    @Test
    public void Line_UNION_WT_TRANSFORM() throws InterruptedException {
        testCommon(Ellipse.name(), Effects.UN_WT_TRANSF.name());
    }
       
              /**
 * test Polygon
 * 
 */
    @Test
    public void Polygon_INTERSECT() throws InterruptedException {
        testCommon(Polygon.name(), Effects.INTERSECT.name());
    }
    
       /**
 * test Polygon
 * 
 */
    @Test
    public void Polygon_SUBTRACT() throws InterruptedException {
        testCommon(Polygon.name(), Effects.SUBTRACT.name());
    }
       /**
 * test Polygon
 * 
 */
    @Test
    public void Polygon_SUBTRACT_WT_DASH() throws InterruptedException {
        testCommon(Polygon.name(), Effects.SUB_WT_DASH.name());
    }
       /**
 * test Polygon
 * 
 */
    @Test
    public void Polygon_UNION() throws InterruptedException {
        testCommon(Polygon.name(), Effects.UNION.name());
    }
       /**
 * test Polygon
 */
    @Test
    public void Polygon_UNION_WT_TRANSFORM() throws InterruptedException {
        testCommon(Polygon.name(), Effects.UN_WT_TRANSF.name());
    }
    
                  /**
 * test Polyline
 * 
 */
    @Test
    public void Polyline_INTERSECT() throws InterruptedException {
        testCommon(Polyline.name(), Effects.INTERSECT.name());
    }
    
       /**
 * test Polyline
 * 
 */
    @Test
    public void Polyline_SUBTRACT() throws InterruptedException {
        testCommon(Polyline.name(), Effects.SUBTRACT.name());
    }
       /**
 * test Polyline
 * 
 */
    @Test
    public void Polyline_SUBTRACT_WT_DASH() throws InterruptedException {
        testCommon(Polyline.name(), Effects.SUB_WT_DASH.name());
    }
       /**
 * test Polyline
 * 
 */
    @Test
    public void Polyline_UNION() throws InterruptedException {
        testCommon(Polyline.name(), Effects.UNION.name());
    }
       /**
 * test Polyline
 */
    @Test
    public void Polyline_UNION_WT_TRANSFORM() throws InterruptedException {
        testCommon(Polyline.name(), Effects.UN_WT_TRANSF.name());
    }
        
                  /**
 * test QuadCurve
 * 
 */
    @Test
    public void QuadCurve_INTERSECT() throws InterruptedException {
        testCommon(QuadCurve.name(), Effects.INTERSECT.name());
    }
    
       /**
 * test QuadCurve
 * 
 */
    @Test
    public void QuadCurve_SUBTRACT() throws InterruptedException {
        testCommon(QuadCurve.name(), Effects.SUBTRACT.name());
    }
       /**
 * test QuadCurve
 * 
 */
    @Test
    public void QuadCurve_SUBTRACT_WT_DASH() throws InterruptedException {
        testCommon(QuadCurve.name(), Effects.SUB_WT_DASH.name());
    }
       /**
 * test QuadCurve
 * 
 */
    @Test
    public void QuadCurve_UNION() throws InterruptedException {
        testCommon(QuadCurve.name(), Effects.UNION.name());
    }
       /**
 * test QuadCurve
 */
    @Test
    public void QuadCurve_UNION_WT_TRANSFORM() throws InterruptedException {
        testCommon(QuadCurve.name(), Effects.UN_WT_TRANSF.name());
    }
            
                  /**
 * test Rectangle
 * 
 */
    @Test
    public void Rectangle_INTERSECT() throws InterruptedException {
        testCommon(Rectangle.name(), Effects.INTERSECT.name());
    }
    
       /**
 * test Rectangle
 * 
 */
    @Test
    public void Rectangle_SUBTRACT() throws InterruptedException {
        testCommon(Rectangle.name(), Effects.SUBTRACT.name());
    }
       /**
 * test Rectangle
 * 
 */
    @Test
    public void Rectangle_SUBTRACT_WT_DASH() throws InterruptedException {
        testCommon(Rectangle.name(), Effects.SUB_WT_DASH.name());
    }
       /**
 * test Rectangle
 * 
 */
    @Test
    public void Rectangle_UNION() throws InterruptedException {
        testCommon(Rectangle.name(), Effects.UNION.name());
    }
       /**
 * test Rectangle
 */
    @Test
    public void Rectangle_UNION_WT_TRANSFORM() throws InterruptedException {
        testCommon(Rectangle.name(), Effects.UN_WT_TRANSF.name());
    }
    
                      /**
 * test ShapeIntersectBevel
 * 
 */
    @Test
    public void ShapeIntersectBevel_INTERSECT() throws InterruptedException {
        testCommon(ShapeIntersectBevel.name(), Effects.INTERSECT.name());
    }
    
       /**
 * test ShapeIntersectBevel
 * 
 */
    @Test
    public void ShapeIntersectBevel_SUBTRACT() throws InterruptedException {
        testCommon(ShapeIntersectBevel.name(), Effects.SUBTRACT.name());
    }
       /**
 * test ShapeIntersectBevel
 * 
 */
    @Test
    public void ShapeIntersectBevel_SUBTRACT_WT_DASH() throws InterruptedException {
        testCommon(ShapeIntersectBevel.name(), Effects.SUB_WT_DASH.name());
    }
       /**
 * test ShapeIntersectBevel
 * 
 */
    @Test
    public void ShapeIntersectBevel_UNION() throws InterruptedException {
        testCommon(ShapeIntersectBevel.name(), Effects.UNION.name());
    }
       /**
 * test ShapeIntersectBevel
 */
    @Test
    public void ShapeIntersectBevel_UNION_WT_TRANSFORM() throws InterruptedException {
        testCommon(ShapeIntersectBevel.name(), Effects.UN_WT_TRANSF.name());
    }
    
                      /**
 * test ShapeIntersectRound
 * 
 */
    @Test
    public void ShapeIntersectRound_INTERSECT() throws InterruptedException {
        testCommon(ShapeIntersectRound.name(), Effects.INTERSECT.name());
    }
    
       /**
 * test ShapeIntersectRound
 * 
 */
    @Test
    public void ShapeIntersectRound_SUBTRACT() throws InterruptedException {
        testCommon(ShapeIntersectRound.name(), Effects.SUBTRACT.name());
    }
       /**
 * test ShapeIntersectRound
 * 
 */
    @Test
    public void ShapeIntersectRound_SUBTRACT_WT_DASH() throws InterruptedException {
        testCommon(ShapeIntersectRound.name(), Effects.SUB_WT_DASH.name());
    }
       /**
 * test ShapeIntersectRound
 * 
 */
    @Test
    public void ShapeIntersectRound_UNION() throws InterruptedException {
        testCommon(ShapeIntersectRound.name(), Effects.UNION.name());
    }
       /**
 * test ShapeIntersectRound
 */
    @Test
    public void ShapeIntersectRound_UNION_WT_TRANSFORM() throws InterruptedException {
        testCommon(ShapeIntersectRound.name(), Effects.UN_WT_TRANSF.name());
    }
                          /**
 * test ShapeIntersect
 * 
 */
    @Test
    public void ShapeIntersect_INTERSECT() throws InterruptedException {
        testCommon(ShapeIntersect.name(), Effects.INTERSECT.name());
    }
    
       /**
 * test ShapeIntersect 
 * 
 */
    @Test
    public void ShapeIntersect_SUBTRACT() throws InterruptedException {
        testCommon(ShapeIntersect.name(), Effects.SUBTRACT.name());
    }
       /**
 * test ShapeIntersect
 * 
 */
    @Test
    public void ShapeIntersect_SUBTRACT_WT_DASH() throws InterruptedException {
        testCommon(ShapeIntersect.name(), Effects.SUB_WT_DASH.name());
    }
       /**
 * test ShapeIntersect
 * 
 */
    @Test
    public void ShapeIntersect_UNION() throws InterruptedException {
        testCommon(ShapeIntersect.name(), Effects.UNION.name());
    }
       /**
 * test ShapeIntersect
 */
    @Test
    public void ShapeIntersect_UNION_WT_TRANSFORM() throws InterruptedException {
        testCommon(ShapeIntersect.name(), Effects.UN_WT_TRANSF.name());
    }
    
                              /**
 * test ShapeSubtract
 * 
 */
    @Test
    public void ShapeSubtract_INTERSECT() throws InterruptedException {
        testCommon(ShapeSubtract.name(), Effects.INTERSECT.name());
    }
    
       /**
 * test ShapeSubtract
 * 
 */
    @Test
    public void ShapeSubtract_SUBTRACT() throws InterruptedException {
        testCommon(ShapeSubtract.name(), Effects.SUBTRACT.name());
    }
       /**
 * test ShapeSubtract
 * 
 */
    @Test
    public void ShapeSubtract_SUBTRACT_WT_DASH() throws InterruptedException {
        testCommon(ShapeSubtract.name(), Effects.SUB_WT_DASH.name());
    }
       /**
 * test ShapeSubtract
 * 
 */
    @Test
    public void ShapeSubtract_UNION() throws InterruptedException {
        testCommon(ShapeSubtract.name(), Effects.UNION.name());
    }
       /**
 * test ShapeSubtract
 */
    @Test
    public void ShapeSubtract_UNION_WT_TRANSFORM() throws InterruptedException {
        testCommon(ShapeSubtract.name(), Effects.UN_WT_TRANSF.name());
    }
    //==============================================================================
/**
 * test Circle
 * with setFill(new LinearGradient(...
 */
    @Test
    public void Circle_LINEAR_GRAD() throws InterruptedException {
        testCommon(Circle.name(), Effects.LINEAR_GRAD.name());
    }

/**
 * test Circle
 * with setStroke(Color.GREEN),setFill(Color.YELLOW);
 */
    @Test
    public void Circle_STROKE() throws InterruptedException {
        testCommon(Circle.name(), Effects.STROKE.name());
    }

/**
 * test Circle
 * with setStroke(new LinearGradient(...)/setStrokeWidth(8f)/setStrokeDashOffset(10f)/setFill(Color.LIGHTGRAY)
 */
    @Test
    public void Circle_STROKE_GRAD() throws InterruptedException {
        testCommon(Circle.name(), Effects.STROKE_GRAD.name());
    }

/**
 * test Circle
 * with setFill(Color.TRANSPARENT)
 */
    @Test
    public void Circle_TRANSPARENT() throws InterruptedException {
        testCommon(Circle.name(), Effects.TRANSPARENT.name());
    }

/**
 * test Circle
 * with setFill(RadialGradient(....
 */
    @Test
    public void Circle_RADIAL_GRADIENT() throws InterruptedException {
        testCommon(Circle.name(), Effects.RADIAL_GRADIENT.name());
    }

/**
 * test Circle
 * with setStroke(Color.GREEN)/getStrokeDashArray().add(4.)/getStrokeDashArray().add(1.)/
 * getStrokeDashArray().add(4.)/setFill(Color.LAVENDERBLUSH);
 */
    @Test
    public void Circle_STROKE_DASH() throws InterruptedException {
        testCommon(Circle.name(), Effects.STROKE_DASH.name());
    }

/**
 * test Circle
 * with setStroke(Color.GREEN)/getStrokeDashArray().add(10.)/getStrokeDashArray().add(8.)/
 * setStrokeWidth(4)/setStrokeLineCap(StrokeLineCap.ROUND)/setFill(Color.WHITE)
 */
    @Test
    public void Circle_STROKE_CAP() throws InterruptedException {
        testCommon(Circle.name(), Effects.STROKE_CAP.name());
    }

/**
 * test Rectangle
 * with setFill(Color.BISQUE)
 */
    @Test
    public void Rectangle_FILL() throws InterruptedException {
        testCommon(Rectangle.name(), Effects.FILL.name());
    }

/**
 * test Rectangle
 * with setFill(new LinearGradient(...
 */
    @Test
    public void Rectangle_LINEAR_GRAD() throws InterruptedException {
        testCommon(Rectangle.name(), Effects.LINEAR_GRAD.name());
    }

/**
 * test Rectangle
 * with setStroke(Color.GREEN),setFill(Color.YELLOW);
 */
    @Test
    public void Rectangle_STROKE() throws InterruptedException {
        testCommon(Rectangle.name(), Effects.STROKE.name());
    }

/**
 * test Rectangle
 * with setStroke(new LinearGradient(...)/setStrokeWidth(8f)/setStrokeDashOffset(10f)/setFill(Color.LIGHTGRAY)
 */
    @Test
    public void Rectangle_STROKE_GRAD() throws InterruptedException {
        testCommon(Rectangle.name(), Effects.STROKE_GRAD.name());
    }

/**
 * test Rectangle
 * with setFill(Color.TRANSPARENT)
 */
    @Test
    public void Rectangle_TRANSPARENT() throws InterruptedException {
        testCommon(Rectangle.name(), Effects.TRANSPARENT.name());
    }

/**
 * test Rectangle
 * with setFill(RadialGradient(....
 */
    @Test
    public void Rectangle_RADIAL_GRADIENT() throws InterruptedException {
        testCommon(Rectangle.name(), Effects.RADIAL_GRADIENT.name());
    }

/**
 * test Rectangle
 * with setStroke(Color.GREEN)/getStrokeDashArray().add(4.)/getStrokeDashArray().add(1.)/
 * getStrokeDashArray().add(4.)/setFill(Color.LAVENDERBLUSH);
 */
    @Test
    public void Rectangle_STROKE_DASH() throws InterruptedException {
        testCommon(Rectangle.name(), Effects.STROKE_DASH.name());
    }

/**
 * test Rectangle
 * with setStroke(Color.GREEN)/getStrokeDashArray().add(10.)/getStrokeDashArray().add(8.)/
 * setStrokeWidth(4)/setStrokeLineCap(StrokeLineCap.ROUND)/setFill(Color.WHITE)
 */
    @Test
    public void Rectangle_STROKE_CAP() throws InterruptedException {
        testCommon(Rectangle.name(), Effects.STROKE_CAP.name());
    }

/**
 * test javafx.scene.shape.CubicCurve
 * with setFill(Color.BISQUE)
 */
    @Test
    public void CubicCurve_FILL() throws InterruptedException {
        testCommon(CubicCurve.name(), Effects.FILL.name());
    }

/**
 * test javafx.scene.shape.CubicCurve
 * with setFill(new LinearGradient(...
 */
    @Test
    public void CubicCurve_LINEAR_GRAD() throws InterruptedException {
        testCommon(CubicCurve.name(), Effects.LINEAR_GRAD.name());
    }

/**
 * test javafx.scene.shape.CubicCurve
 * with setStroke(Color.GREEN),setFill(Color.YELLOW);
 */
    @Test
    public void CubicCurve_STROKE() throws InterruptedException {
        testCommon(CubicCurve.name(), Effects.STROKE.name());
    }

/**
 * test javafx.scene.shape.CubicCurve
 * with setStroke(new LinearGradient(...)/setStrokeWidth(8f)/setStrokeDashOffset(10f)/setFill(Color.LIGHTGRAY)
 */
    @Test
    public void CubicCurve_STROKE_GRAD() throws InterruptedException {
        testCommon(CubicCurve.name(), Effects.STROKE_GRAD.name());
    }

/**
 * test javafx.scene.shape.CubicCurve
 * with setFill(Color.TRANSPARENT)
 */
    @Test
    public void CubicCurve_TRANSPARENT() throws InterruptedException {
        testCommon(CubicCurve.name(), Effects.TRANSPARENT.name());
    }

/**
 * test javafx.scene.shape.CubicCurve
 * with setFill(RadialGradient(....
 */
    @Test
    public void CubicCurve_RADIAL_GRADIENT() throws InterruptedException {
        testCommon(CubicCurve.name(), Effects.RADIAL_GRADIENT.name());
    }

/**
 * test javafx.scene.shape.CubicCurve
 * with setStroke(Color.GREEN)/getStrokeDashArray().add(4.)/getStrokeDashArray().add(1.)/
 * getStrokeDashArray().add(4.)/setFill(Color.LAVENDERBLUSH);
 */
    @Test
    public void CubicCurve_STROKE_DASH() throws InterruptedException {
        testCommon(CubicCurve.name(), Effects.STROKE_DASH.name());
    }

/**
 * test javafx.scene.shape.CubicCurve
 * with setStroke(Color.GREEN)/getStrokeDashArray().add(10.)/getStrokeDashArray().add(8.)/
 * setStrokeWidth(4)/setStrokeLineCap(StrokeLineCap.ROUND)/setFill(Color.WHITE)
 */
    @Test
    public void CubicCurve_STROKE_CAP() throws InterruptedException {
        testCommon(CubicCurve.name(), Effects.STROKE_CAP.name());
    }

/**
 * test javafx.scene.shape.QuadCurve
 * with setFill(Color.BISQUE)
 */
    @Test
    public void QuadCurve_FILL() throws InterruptedException {
        testCommon(QuadCurve.name(), Effects.FILL.name());
    }

/**
 * test javafx.scene.shape.QuadCurve
 * with setFill(new LinearGradient(...
 */
    @Test
    public void QuadCurve_LINEAR_GRAD() throws InterruptedException {
        testCommon(QuadCurve.name(), Effects.LINEAR_GRAD.name());
    }

/**
 * test javafx.scene.shape.QuadCurve
 * with setStroke(Color.GREEN),setFill(Color.YELLOW);
 */
    @Test
    public void QuadCurve_STROKE() throws InterruptedException {
        testCommon(QuadCurve.name(), Effects.STROKE.name());
    }

/**
 * test javafx.scene.shape.QuadCurve
 * with setStroke(new LinearGradient(...)/setStrokeWidth(8f)/setStrokeDashOffset(10f)/setFill(Color.LIGHTGRAY)
 */
    @Test
    public void QuadCurve_STROKE_GRAD() throws InterruptedException {
        testCommon(QuadCurve.name(), Effects.STROKE_GRAD.name());
    }

/**
 * test javafx.scene.shape.QuadCurve
 * with setFill(Color.TRANSPARENT)
 */
    @Test
    public void QuadCurve_TRANSPARENT() throws InterruptedException {
        testCommon(QuadCurve.name(), Effects.TRANSPARENT.name());
    }

/**
 * test javafx.scene.shape.QuadCurve
 * with setFill(RadialGradient(....
 */
    @Test
    public void QuadCurve_RADIAL_GRADIENT() throws InterruptedException {
        testCommon(QuadCurve.name(), Effects.RADIAL_GRADIENT.name());
    }

/**
 * test javafx.scene.shape.QuadCurve
 * with setStroke(Color.GREEN)/getStrokeDashArray().add(4.)/getStrokeDashArray().add(1.)/
 * getStrokeDashArray().add(4.)/setFill(Color.LAVENDERBLUSH);
 */
    @Test
    public void QuadCurve_STROKE_DASH() throws InterruptedException {
        testCommon(QuadCurve.name(), Effects.STROKE_DASH.name());
    }

/**
 * test javafx.scene.shape.QuadCurve
 * with setStroke(Color.GREEN)/getStrokeDashArray().add(10.)/getStrokeDashArray().add(8.)/
 * setStrokeWidth(4)/setStrokeLineCap(StrokeLineCap.ROUND)/setFill(Color.WHITE)
 */
    @Test
    public void QuadCurve_STROKE_CAP() throws InterruptedException {
        testCommon(QuadCurve.name(), Effects.STROKE_CAP.name());
    }

/**
 * test javafx.scene.shape.Polygon
 * with setFill(Color.BISQUE)
 */
    @Test
    public void Polygon_FILL() throws InterruptedException {
        testCommon(Polygon.name(), Effects.FILL.name());
    }

/**
 * test javafx.scene.shape.Polygon
 * with setFill(new LinearGradient(...
 */
    @Test
    public void Polygon_LINEAR_GRAD() throws InterruptedException {
        testCommon(Polygon.name(), Effects.LINEAR_GRAD.name());
    }

/**
 * test javafx.scene.shape.Polygon
 * with setStroke(Color.GREEN),setFill(Color.YELLOW);
 */
    @Test
    public void Polygon_STROKE() throws InterruptedException {
        testCommon(Polygon.name(), Effects.STROKE.name());
    }

/**
 * test javafx.scene.shape.Polygon
 * with setStroke(new LinearGradient(...)/setStrokeWidth(8f)/setStrokeDashOffset(10f)/setFill(Color.LIGHTGRAY)
 */
    @Test
    public void Polygon_STROKE_GRAD() throws InterruptedException {
        testCommon(Polygon.name(), Effects.STROKE_GRAD.name());
    }

/**
 * test javafx.scene.shape.Polygon
 * with setFill(Color.TRANSPARENT)
 */
    @Test
    public void Polygon_TRANSPARENT() throws InterruptedException {
        testCommon(Polygon.name(), Effects.TRANSPARENT.name());
    }

/**
 * test javafx.scene.shape.Polygon
 * with setFill(RadialGradient(....
 */
    @Test
    public void Polygon_RADIAL_GRADIENT() throws InterruptedException {
        testCommon(Polygon.name(), Effects.RADIAL_GRADIENT.name());
    }

/**
 * test javafx.scene.shape.Polygon
 * with setStroke(Color.GREEN)/getStrokeDashArray().add(4.)/getStrokeDashArray().add(1.)/
 * getStrokeDashArray().add(4.)/setFill(Color.LAVENDERBLUSH);
 */
    @Test
    public void Polygon_STROKE_DASH() throws InterruptedException {
        testCommon(Polygon.name(), Effects.STROKE_DASH.name());
    }

/**
 * test javafx.scene.shape.Polygon
 * with setStroke(Color.GREEN)/getStrokeDashArray().add(10.)/getStrokeDashArray().add(8.)/
 * setStrokeWidth(4)/setStrokeLineCap(StrokeLineCap.ROUND)/setFill(Color.WHITE)
 */
    @Test
    public void Polygon_STROKE_CAP() throws InterruptedException {
        testCommon(Polygon.name(), Effects.STROKE_CAP.name());
    }

/**
 * test ShapeIntersect with setStrokeLineJoin(StrokeLineJoin.MITER)
 * with setFill(Color.BISQUE)
 */
    @Test
    public void ShapeIntersect_FILL() throws InterruptedException {
        testCommon(ShapeIntersect.name(), Effects.FILL.name());
    }

/**
 * test ShapeIntersect with setStrokeLineJoin(StrokeLineJoin.MITER)
 * with setFill(new LinearGradient(...
 */
    @Test
    public void ShapeIntersect_LINEAR_GRAD() throws InterruptedException {
        testCommon(ShapeIntersect.name(), Effects.LINEAR_GRAD.name());
    }

/**
 * test ShapeIntersect with setStrokeLineJoin(StrokeLineJoin.MITER)
 * with setStroke(Color.GREEN),setFill(Color.YELLOW);
 */
    @Test
    public void ShapeIntersect_STROKE() throws InterruptedException {
        testCommon(ShapeIntersect.name(), Effects.STROKE.name());
    }

/**
 * test ShapeIntersect with setStrokeLineJoin(StrokeLineJoin.MITER)
 * with setStroke(new LinearGradient(...)/setStrokeWidth(8f)/setStrokeDashOffset(10f)/setFill(Color.LIGHTGRAY)
 */
    @Test
    public void ShapeIntersect_STROKE_GRAD() throws InterruptedException {
        testCommon(ShapeIntersect.name(), Effects.STROKE_GRAD.name());
    }

/**
 * test ShapeIntersect with setStrokeLineJoin(StrokeLineJoin.MITER)
 * with setFill(Color.TRANSPARENT)
 */
    @Test
    public void ShapeIntersect_TRANSPARENT() throws InterruptedException {
        testCommon(ShapeIntersect.name(), Effects.TRANSPARENT.name());
    }

/**
 * test ShapeIntersect with setStrokeLineJoin(StrokeLineJoin.MITER)
 * with setFill(RadialGradient(....
 */
    @Test
    public void ShapeIntersect_RADIAL_GRADIENT() throws InterruptedException {
        testCommon(ShapeIntersect.name(), Effects.RADIAL_GRADIENT.name());
    }

/**
 * test ShapeIntersect with setStrokeLineJoin(StrokeLineJoin.MITER)
 * with setStroke(Color.GREEN)/getStrokeDashArray().add(4.)/getStrokeDashArray().add(1.)/
 * getStrokeDashArray().add(4.)/setFill(Color.LAVENDERBLUSH);
 */
    @Test
    public void ShapeIntersect_STROKE_DASH() throws InterruptedException {
        testCommon(ShapeIntersect.name(), Effects.STROKE_DASH.name());
    }

/**
 * test ShapeIntersect with setStrokeLineJoin(StrokeLineJoin.MITER)
 * with setStroke(Color.GREEN)/getStrokeDashArray().add(10.)/getStrokeDashArray().add(8.)/
 * setStrokeWidth(4)/setStrokeLineCap(StrokeLineCap.ROUND)/setFill(Color.WHITE)
 */
    @Test
    public void ShapeIntersect_STROKE_CAP() throws InterruptedException {
        testCommon(ShapeIntersect.name(), Effects.STROKE_CAP.name());
    }

/**
 * test ShapeIntersect with setStrokeLineJoin(StrokeLineJoin.ROUND)
 * with setFill(Color.BISQUE)
 */
    @Test
    public void ShapeIntersectRound_FILL() throws InterruptedException {
        testCommon(ShapeIntersectRound.name(), Effects.FILL.name());
    }

/**
 * test ShapeIntersect with setStrokeLineJoin(StrokeLineJoin.ROUND)
 * with setFill(new LinearGradient(...
 */
    @Test
    public void ShapeIntersectRound_LINEAR_GRAD() throws InterruptedException {
        testCommon(ShapeIntersectRound.name(), Effects.LINEAR_GRAD.name());
    }

/**
 * test ShapeIntersect with setStrokeLineJoin(StrokeLineJoin.ROUND)
 * with setStroke(Color.GREEN),setFill(Color.YELLOW);
 */
    @Test
    public void ShapeIntersectRound_STROKE() throws InterruptedException {
        testCommon(ShapeIntersectRound.name(), Effects.STROKE.name());
    }

/**
 * test ShapeIntersect with setStrokeLineJoin(StrokeLineJoin.ROUND)
 * with setStroke(new LinearGradient(...)/setStrokeWidth(8f)/setStrokeDashOffset(10f)/setFill(Color.LIGHTGRAY)
 */
    @Test
    public void ShapeIntersectRound_STROKE_GRAD() throws InterruptedException {
        testCommon(ShapeIntersectRound.name(), Effects.STROKE_GRAD.name());
    }

/**
 * test ShapeIntersect with setStrokeLineJoin(StrokeLineJoin.ROUND)
 * with setFill(Color.TRANSPARENT)
 */
    @Test
    public void ShapeIntersectRound_TRANSPARENT() throws InterruptedException {
        testCommon(ShapeIntersectRound.name(), Effects.TRANSPARENT.name());
    }

/**
 * test ShapeIntersect with setStrokeLineJoin(StrokeLineJoin.ROUND)
 * with setFill(RadialGradient(....
 */
    @Test
    public void ShapeIntersectRound_RADIAL_GRADIENT() throws InterruptedException {
        testCommon(ShapeIntersectRound.name(), Effects.RADIAL_GRADIENT.name());
    }

/**
 * test ShapeIntersect with setStrokeLineJoin(StrokeLineJoin.ROUND)
 * with setStroke(Color.GREEN)/getStrokeDashArray().add(4.)/getStrokeDashArray().add(1.)/
 * getStrokeDashArray().add(4.)/setFill(Color.LAVENDERBLUSH);
 */
    @Test
    public void ShapeIntersectRound_STROKE_DASH() throws InterruptedException {
        testCommon(ShapeIntersectRound.name(), Effects.STROKE_DASH.name());
    }

/**
 * test ShapeIntersect with setStrokeLineJoin(StrokeLineJoin.ROUND)
 * with setStroke(Color.GREEN)/getStrokeDashArray().add(10.)/getStrokeDashArray().add(8.)/
 * setStrokeWidth(4)/setStrokeLineCap(StrokeLineCap.ROUND)/setFill(Color.WHITE)
 */
    @Test
    public void ShapeIntersectRound_STROKE_CAP() throws InterruptedException {
        testCommon(ShapeIntersectRound.name(), Effects.STROKE_CAP.name());
    }

/**
 * test ShapeIntersect with setStrokeLineJoin(StrokeLineJoin.BEVEL)
 * with setFill(Color.BISQUE)
 */
    @Test
    public void ShapeIntersectBevel_FILL() throws InterruptedException {
        testCommon(ShapeIntersectBevel.name(), Effects.FILL.name());
    }

/**
 * test ShapeIntersect with setStrokeLineJoin(StrokeLineJoin.BEVEL)
 * with setFill(new LinearGradient(...
 */
    @Test
    public void ShapeIntersectBevel_LINEAR_GRAD() throws InterruptedException {
        testCommon(ShapeIntersectBevel.name(), Effects.LINEAR_GRAD.name());
    }

/**
 * test ShapeIntersect with setStrokeLineJoin(StrokeLineJoin.BEVEL)
 * with setStroke(Color.GREEN),setFill(Color.YELLOW);
 */
    @Test
    public void ShapeIntersectBevel_STROKE() throws InterruptedException {
        testCommon(ShapeIntersectBevel.name(), Effects.STROKE.name());
    }

/**
 * test ShapeIntersect with setStrokeLineJoin(StrokeLineJoin.BEVEL)
 * with setStroke(new LinearGradient(...)/setStrokeWidth(8f)/setStrokeDashOffset(10f)/setFill(Color.LIGHTGRAY)
 */
    @Test
    public void ShapeIntersectBevel_STROKE_GRAD() throws InterruptedException {
        testCommon(ShapeIntersectBevel.name(), Effects.STROKE_GRAD.name());
    }

/**
 * test ShapeIntersect with setStrokeLineJoin(StrokeLineJoin.BEVEL)
 * with setFill(Color.TRANSPARENT)
 */
    @Test
    public void ShapeIntersectBevel_TRANSPARENT() throws InterruptedException {
        testCommon(ShapeIntersectBevel.name(), Effects.TRANSPARENT.name());
    }

/**
 * test ShapeIntersect with setStrokeLineJoin(StrokeLineJoin.BEVEL)
 * with setFill(RadialGradient(....
 */
    @Test
    public void ShapeIntersectBevel_RADIAL_GRADIENT() throws InterruptedException {
        testCommon(ShapeIntersectBevel.name(), Effects.RADIAL_GRADIENT.name());
    }

/**
 * test ShapeIntersect with setStrokeLineJoin(StrokeLineJoin.BEVEL)
 * with setStroke(Color.GREEN)/getStrokeDashArray().add(4.)/getStrokeDashArray().add(1.)/
 * getStrokeDashArray().add(4.)/setFill(Color.LAVENDERBLUSH);
 */
    @Test
    public void ShapeIntersectBevel_STROKE_DASH() throws InterruptedException {
        testCommon(ShapeIntersectBevel.name(), Effects.STROKE_DASH.name());
    }

/**
 * test ShapeIntersect with setStrokeLineJoin(StrokeLineJoin.BEVEL)
 * with setStroke(Color.GREEN)/getStrokeDashArray().add(10.)/getStrokeDashArray().add(8.)/
 * setStrokeWidth(4)/setStrokeLineCap(StrokeLineCap.ROUND)/setFill(Color.WHITE)
 */
    @Test
    public void ShapeIntersectBevel_STROKE_CAP() throws InterruptedException {
        testCommon(ShapeIntersectBevel.name(), Effects.STROKE_CAP.name());
    }


/**
 * test ShapeSubtract
 * with setFill(Color.BISQUE)
 */
    @Test
    public void ShapeSubtract_FILL() throws InterruptedException {
        testCommon(ShapeSubtract.name(), Effects.FILL.name());
    }

/**
 * test ShapeSubtract
 * with setFill(new LinearGradient(...
 */
    @Test
    public void ShapeSubtract_LINEAR_GRAD() throws InterruptedException {
        testCommon(ShapeSubtract.name(), Effects.LINEAR_GRAD.name());
    }

/**
 * test ShapeSubtract
 * with setStroke(Color.GREEN),setFill(Color.YELLOW);
 */
    @Test
    public void ShapeSubtract_STROKE() throws InterruptedException {
        testCommon(ShapeSubtract.name(), Effects.STROKE.name());
    }

/**
 * test ShapeSubtract
 * with setStroke(new LinearGradient(...)/setStrokeWidth(8f)/setStrokeDashOffset(10f)/setFill(Color.LIGHTGRAY)
 */
    @Test
    public void ShapeSubtract_STROKE_GRAD() throws InterruptedException {
        testCommon(ShapeSubtract.name(), Effects.STROKE_GRAD.name());
    }

/**
 * test ShapeSubtract
 * with setFill(Color.TRANSPARENT)
 */
    @Test
    public void ShapeSubtract_TRANSPARENT() throws InterruptedException {
        testCommon(ShapeSubtract.name(), Effects.TRANSPARENT.name());
    }

/**
 * test ShapeSubtract
 * with setFill(RadialGradient(....
 */
    @Test
    public void ShapeSubtract_RADIAL_GRADIENT() throws InterruptedException {
        testCommon(ShapeSubtract.name(), Effects.RADIAL_GRADIENT.name());
    }

/**
 * test ShapeSubtract
 * with setStroke(Color.GREEN)/getStrokeDashArray().add(4.)/getStrokeDashArray().add(1.)/
 * getStrokeDashArray().add(4.)/setFill(Color.LAVENDERBLUSH);
 */
    @Test
    public void ShapeSubtract_STROKE_DASH() throws InterruptedException {
        testCommon(ShapeSubtract.name(), Effects.STROKE_DASH.name());
    }

/**
 * test ShapeSubtract
 * with setStroke(Color.GREEN)/getStrokeDashArray().add(10.)/getStrokeDashArray().add(8.)/
 * setStrokeWidth(4)/setStrokeLineCap(StrokeLineCap.ROUND)/setFill(Color.WHITE)
 */
    @Test
    public void ShapeSubtract_STROKE_CAP() throws InterruptedException {
        testCommon(ShapeSubtract.name(), Effects.STROKE_CAP.name());
    }

/**
 * test Ellipse
 * with setFill(Color.BISQUE)
 */
    @Test
    public void Ellipse_FILL() throws InterruptedException {
        testCommon(Ellipse.name(), Effects.FILL.name());
    }

/**
 * test Ellipse
 * with setFill(new LinearGradient(...
 */
    @Test
    public void Ellipse_LINEAR_GRAD() throws InterruptedException {
        testCommon(Ellipse.name(), Effects.LINEAR_GRAD.name());
    }

/**
 * test Ellipse
 * with setStroke(Color.GREEN),setFill(Color.YELLOW);
 */
    @Test
    public void Ellipse_STROKE() throws InterruptedException {
        testCommon(Ellipse.name(), Effects.STROKE.name());
    }

/**
 * test Ellipse
 * with setStroke(new LinearGradient(...)/setStrokeWidth(8f)/setStrokeDashOffset(10f)/setFill(Color.LIGHTGRAY)
 */
    @Test
    public void Ellipse_STROKE_GRAD() throws InterruptedException {
        testCommon(Ellipse.name(), Effects.STROKE_GRAD.name());
    }

/**
 * test Ellipse
 * with setFill(Color.TRANSPARENT)
 */
    @Test
    public void Ellipse_TRANSPARENT() throws InterruptedException {
        testCommon(Ellipse.name(), Effects.TRANSPARENT.name());
    }

/**
 * test Ellipse
 * with setFill(RadialGradient(....
 */
    @Test
    public void Ellipse_RADIAL_GRADIENT() throws InterruptedException {
        testCommon(Ellipse.name(), Effects.RADIAL_GRADIENT.name());
    }

/**
 * test Ellipse
 * with setStroke(Color.GREEN)/getStrokeDashArray().add(4.)/getStrokeDashArray().add(1.)/
 * getStrokeDashArray().add(4.)/setFill(Color.LAVENDERBLUSH);
 */
    @Test
    public void Ellipse_STROKE_DASH() throws InterruptedException {
        testCommon(Ellipse.name(), Effects.STROKE_DASH.name());
    }

/**
 * test Ellipse
 * with setStroke(Color.GREEN)/getStrokeDashArray().add(10.)/getStrokeDashArray().add(8.)/
 * setStrokeWidth(4)/setStrokeLineCap(StrokeLineCap.ROUND)/setFill(Color.WHITE)
 */
    @Test
    public void Ellipse_STROKE_CAP() throws InterruptedException {
        testCommon(Ellipse.name(), Effects.STROKE_CAP.name());
    }



/**
 * test javafx.scene.shape.Arc
 * with setFill(Color.BISQUE)
 */
    @Test
    public void Arc_FILL() throws InterruptedException {
        testCommon(Arc.name(), Effects.FILL.name());
    }

/**
 * test javafx.scene.shape.Arc
 * with setFill(new LinearGradient(...
 */
    @Test
    public void Arc_LINEAR_GRAD() throws InterruptedException {
        testCommon(Arc.name(), Effects.LINEAR_GRAD.name());
    }

/**
 * test javafx.scene.shape.Arc
 * with setStroke(Color.GREEN),setFill(Color.YELLOW);
 */
    @Test
    public void Arc_STROKE() throws InterruptedException {
        testCommon(Arc.name(), Effects.STROKE.name());
    }

/**
 * test javafx.scene.shape.Arc
 * with setStroke(new LinearGradient(...)/setStrokeWidth(8f)/setStrokeDashOffset(10f)/setFill(Color.LIGHTGRAY)
 */
    @Test
    public void Arc_STROKE_GRAD() throws InterruptedException {
        testCommon(Arc.name(), Effects.STROKE_GRAD.name());
    }

/**
 * test javafx.scene.shape.Arc
 * with setFill(Color.TRANSPARENT)
 */
    @Test
    public void Arc_TRANSPARENT() throws InterruptedException {
        testCommon(Arc.name(), Effects.TRANSPARENT.name());
    }

/**
 * test javafx.scene.shape.Arc
 * with setFill(RadialGradient(....
 */
    @Test
    public void Arc_RADIAL_GRADIENT() throws InterruptedException {
        testCommon(Arc.name(), Effects.RADIAL_GRADIENT.name());
    }

/**
 * test javafx.scene.shape.Arc
 * with setStroke(Color.GREEN)/getStrokeDashArray().add(4.)/getStrokeDashArray().add(1.)/
 * getStrokeDashArray().add(4.)/setFill(Color.LAVENDERBLUSH);
 */
    @Test
    public void Arc_STROKE_DASH() throws InterruptedException {
        testCommon(Arc.name(), Effects.STROKE_DASH.name());
    }

/**
 * test javafx.scene.shape.Arc
 * with setStroke(Color.GREEN)/getStrokeDashArray().add(10.)/getStrokeDashArray().add(8.)/
 * setStrokeWidth(4)/setStrokeLineCap(StrokeLineCap.ROUND)/setFill(Color.WHITE)
 */
    @Test
    public void Arc_STROKE_CAP() throws InterruptedException {
        testCommon(Arc.name(), Effects.STROKE_CAP.name());
    }

/**
 * test javafx.scene.shape.Line
 * with setFill(Color.BISQUE)
 */
    @Test
    public void Line_FILL() throws InterruptedException {
        testCommon(Line.name(), Effects.FILL.name());
    }

/**
 * test javafx.scene.shape.Line
 * with setFill(new LinearGradient(...
 */
    @Test
    public void Line_LINEAR_GRAD() throws InterruptedException {
        testCommon(Line.name(), Effects.LINEAR_GRAD.name());
    }

/**
 * test javafx.scene.shape.Line
 * with setStroke(Color.GREEN),setFill(Color.YELLOW);
 */
    @Test
    public void Line_STROKE() throws InterruptedException {
        testCommon(Line.name(), Effects.STROKE.name());
    }

/**
 * test javafx.scene.shape.Line
 * with setStroke(new LinearGradient(...)/setStrokeWidth(8f)/setStrokeDashOffset(10f)/setFill(Color.LIGHTGRAY)
 */
    @Test
    public void Line_STROKE_GRAD() throws InterruptedException {
        testCommon(Line.name(), Effects.STROKE_GRAD.name());
    }

/**
 * test javafx.scene.shape.Line
 * with setFill(Color.TRANSPARENT)
 */
    @Test
    public void Line_TRANSPARENT() throws InterruptedException {
        testCommon(Line.name(), Effects.TRANSPARENT.name());
    }

/**
 * test javafx.scene.shape.Line
 * with setFill(RadialGradient(....
 */
    @Test
    public void Line_RADIAL_GRADIENT() throws InterruptedException {
        testCommon(Line.name(), Effects.RADIAL_GRADIENT.name());
    }

/**
 * test javafx.scene.shape.Line
 * with setStroke(Color.GREEN)/getStrokeDashArray().add(4.)/getStrokeDashArray().add(1.)/
 * getStrokeDashArray().add(4.)/setFill(Color.LAVENDERBLUSH);
 */
    @Test
    public void Line_STROKE_DASH() throws InterruptedException {
        testCommon(Line.name(), Effects.STROKE_DASH.name());
    }

/**
 * test javafx.scene.shape.Line
 * with setStroke(Color.GREEN)/getStrokeDashArray().add(10.)/getStrokeDashArray().add(8.)/
 * setStrokeWidth(4)/setStrokeLineCap(StrokeLineCap.ROUND)/setFill(Color.WHITE)
 */
    @Test
    public void Line_STROKE_CAP() throws InterruptedException {
        testCommon(Line.name(), Effects.STROKE_CAP.name());
    }



/**
 * test javafx.scene.shape.Polyline
 * with setFill(Color.BISQUE)
 */
    @Test
    public void Polyline_FILL() throws InterruptedException {
        testCommon(Polyline.name(), Effects.FILL.name());
    }

/**
 * test javafx.scene.shape.Polyline
 * with setFill(new LinearGradient(...
 */
    @Test
    public void Polyline_LINEAR_GRAD() throws InterruptedException {
        testCommon(Polyline.name(), Effects.LINEAR_GRAD.name());
    }

/**
 * test javafx.scene.shape.Polyline
 * with setStroke(Color.GREEN),setFill(Color.YELLOW);
 */
    @Test
    public void Polyline_STROKE() throws InterruptedException {
        testCommon(Polyline.name(), Effects.STROKE.name());
    }

/**
 * test javafx.scene.shape.Polyline
 * with setStroke(new LinearGradient(...)/setStrokeWidth(8f)/setStrokeDashOffset(10f)/setFill(Color.LIGHTGRAY)
 */
    @Test
    public void Polyline_STROKE_GRAD() throws InterruptedException {
        testCommon(Polyline.name(), Effects.STROKE_GRAD.name());
    }

/**
 * test javafx.scene.shape.Polyline
 * with setFill(Color.TRANSPARENT)
 */
    @Test
    public void Polyline_TRANSPARENT() throws InterruptedException {
        testCommon(Polyline.name(), Effects.TRANSPARENT.name());
    }

/**
 * test javafx.scene.shape.Polyline
 * with setFill(RadialGradient(....
 */
    @Test
    public void Polyline_RADIAL_GRADIENT() throws InterruptedException {
        testCommon(Polyline.name(), Effects.RADIAL_GRADIENT.name());
    }

/**
 * test javafx.scene.shape.Polyline
 * with setStroke(Color.GREEN)/getStrokeDashArray().add(4.)/getStrokeDashArray().add(1.)/
 * getStrokeDashArray().add(4.)/setFill(Color.LAVENDERBLUSH);
 */
    @Test
    public void Polyline_STROKE_DASH() throws InterruptedException {
        testCommon(Polyline.name(), Effects.STROKE_DASH.name());
    }

/**
 * test javafx.scene.shape.Polyline
 * with setStroke(Color.GREEN)/getStrokeDashArray().add(10.)/getStrokeDashArray().add(8.)/
 * setStrokeWidth(4)/setStrokeLineCap(StrokeLineCap.ROUND)/setFill(Color.WHITE)
 */
    @Test
    public void Polyline_STROKE_CAP() throws InterruptedException {
        testCommon(Polyline.name(), Effects.STROKE_CAP.name());
    }

    @Override
    public void testCommon(String toplevel_name, String innerlevel_name) {

     boolean commonTestPassed = true;
     setWaitImageDelay(300);
        try {
            testCommon(toplevel_name, innerlevel_name, true, false);
        } catch (org.jemmy.TimeoutExpiredException ex) {
            commonTestPassed = false;
        }
        testRenderSceneToImage (toplevel_name, innerlevel_name);
        if (!commonTestPassed) {
            throw new org.jemmy.TimeoutExpiredException("testCommon failed:" + toplevel_name + "-" + innerlevel_name);
        }
    }

    @Override
    protected String getName() {
        return "Shape2Test";
    }
}
