/*
 * The GNU General Public License (GPL)
 *
 * Version 2, June 1991
 *
 * Copyright (C) 1989, 1991 Free Software Foundation, Inc.
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 * Everyone is permitted to copy and distribute verbatim copies of this license
 * document, but changing it is not allowed.
 *
 * Preamble
 *
 * The licenses for most software are designed to take away your freedom to share
 * and change it.  By contrast, the GNU General Public License is intended to
 * guarantee your freedom to share and change free software--to make sure the
 * software is free for all its users.  This General Public License applies to
 * most of the Free Software Foundation's software and to any other program whose
 * authors commit to using it.  (Some other Free Software Foundation software is
 * covered by the GNU Library General Public License instead.) You can apply it to
 * your programs, too.
 *
 * When we speak of free software, we are referring to freedom, not price.  Our
 * General Public Licenses are designed to make sure that you have the freedom to
 * distribute copies of free software (and charge for this service if you wish),
 * that you receive source code or can get it if you want it, that you can change
 * the software or use pieces of it in new free programs; and that you know you
 * can do these things.
 *
 * To protect your rights, we need to make restrictions that forbid anyone to deny
 * you these rights or to ask you to surrender the rights.  These restrictions
 * translate to certain responsibilities for you if you distribute copies of the
 * software, or if you modify it.
 *
 * For example, if you distribute copies of such a program, whether gratis or for
 * a fee, you must give the recipients all the rights that you have.  You must
 * make sure that they, too, receive or can get the source code.  And you must
 * show them these terms so they know their rights.
 *
 * We protect your rights with two steps: (1) copyright the software, and (2)
 * offer you this license which gives you legal permission to copy, distribute
 * and/or modify the software.
 *
 * Also, for each author's protection and ours, we want to make certain that
 * everyone understands that there is no warranty for this free software.  If the
 * software is modified by someone else and passed on, we want its recipients to
 * know that what they have is not the original, so that any problems introduced
 * by others will not reflect on the original authors' reputations.
 *
 * Finally, any free program is threatened constantly by software patents.  We
 * wish to avoid the danger that redistributors of a free program will
 * individually obtain patent licenses, in effect making the program proprietary.
 * To prevent this, we have made it clear that any patent must be licensed for
 * everyone's free use or not licensed at all.
 *
 * The precise terms and conditions for copying, distribution and modification
 * follow.
 *
 * TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
 *
 * 0. This License applies to any program or other work which contains a notice
 * placed by the copyright holder saying it may be distributed under the terms of
 * this General Public License.  The "Program", below, refers to any such program
 * or work, and a "work based on the Program" means either the Program or any
 * derivative work under copyright law: that is to say, a work containing the
 * Program or a portion of it, either verbatim or with modifications and/or
 * translated into another language.  (Hereinafter, translation is included
 * without limitation in the term "modification".) Each licensee is addressed as
 * "you".
 *
 * Activities other than copying, distribution and modification are not covered by
 * this License; they are outside its scope.  The act of running the Program is
 * not restricted, and the output from the Program is covered only if its contents
 * constitute a work based on the Program (independent of having been made by
 * running the Program).  Whether that is true depends on what the Program does.
 *
 * 1. You may copy and distribute verbatim copies of the Program's source code as
 * you receive it, in any medium, provided that you conspicuously and
 * appropriately publish on each copy an appropriate copyright notice and
 * disclaimer of warranty; keep intact all the notices that refer to this License
 * and to the absence of any warranty; and give any other recipients of the
 * Program a copy of this License along with the Program.
 *
 * You may charge a fee for the physical act of transferring a copy, and you may
 * at your option offer warranty protection in exchange for a fee.
 *
 * 2. You may modify your copy or copies of the Program or any portion of it, thus
 * forming a work based on the Program, and copy and distribute such modifications
 * or work under the terms of Section 1 above, provided that you also meet all of
 * these conditions:
 *
 *     a) You must cause the modified files to carry prominent notices stating
 *     that you changed the files and the date of any change.
 *
 *     b) You must cause any work that you distribute or publish, that in whole or
 *     in part contains or is derived from the Program or any part thereof, to be
 *     licensed as a whole at no charge to all third parties under the terms of
 *     this License.
 *
 *     c) If the modified program normally reads commands interactively when run,
 *     you must cause it, when started running for such interactive use in the
 *     most ordinary way, to print or display an announcement including an
 *     appropriate copyright notice and a notice that there is no warranty (or
 *     else, saying that you provide a warranty) and that users may redistribute
 *     the program under these conditions, and telling the user how to view a copy
 *     of this License.  (Exception: if the Program itself is interactive but does
 *     not normally print such an announcement, your work based on the Program is
 *     not required to print an announcement.)
 *
 * These requirements apply to the modified work as a whole.  If identifiable
 * sections of that work are not derived from the Program, and can be reasonably
 * considered independent and separate works in themselves, then this License, and
 * its terms, do not apply to those sections when you distribute them as separate
 * works.  But when you distribute the same sections as part of a whole which is a
 * work based on the Program, the distribution of the whole must be on the terms
 * of this License, whose permissions for other licensees extend to the entire
 * whole, and thus to each and every part regardless of who wrote it.
 *
 * Thus, it is not the intent of this section to claim rights or contest your
 * rights to work written entirely by you; rather, the intent is to exercise the
 * right to control the distribution of derivative or collective works based on
 * the Program.
 *
 * In addition, mere aggregation of another work not based on the Program with the
 * Program (or with a work based on the Program) on a volume of a storage or
 * distribution medium does not bring the other work under the scope of this
 * License.
 *
 * 3. You may copy and distribute the Program (or a work based on it, under
 * Section 2) in object code or executable form under the terms of Sections 1 and
 * 2 above provided that you also do one of the following:
 *
 *     a) Accompany it with the complete corresponding machine-readable source
 *     code, which must be distributed under the terms of Sections 1 and 2 above
 *     on a medium customarily used for software interchange; or,
 *
 *     b) Accompany it with a written offer, valid for at least three years, to
 *     give any third party, for a charge no more than your cost of physically
 *     performing source distribution, a complete machine-readable copy of the
 *     corresponding source code, to be distributed under the terms of Sections 1
 *     and 2 above on a medium customarily used for software interchange; or,
 *
 *     c) Accompany it with the information you received as to the offer to
 *     distribute corresponding source code.  (This alternative is allowed only
 *     for noncommercial distribution and only if you received the program in
 *     object code or executable form with such an offer, in accord with
 *     Subsection b above.)
 *
 * The source code for a work means the preferred form of the work for making
 * modifications to it.  For an executable work, complete source code means all
 * the source code for all modules it contains, plus any associated interface
 * definition files, plus the scripts used to control compilation and installation
 * of the executable.  However, as a special exception, the source code
 * distributed need not include anything that is normally distributed (in either
 * source or binary form) with the major components (compiler, kernel, and so on)
 * of the operating system on which the executable runs, unless that component
 * itself accompanies the executable.
 *
 * If distribution of executable or object code is made by offering access to copy
 * from a designated place, then offering equivalent access to copy the source
 * code from the same place counts as distribution of the source code, even though
 * third parties are not compelled to copy the source along with the object code.
 *
 * 4. You may not copy, modify, sublicense, or distribute the Program except as
 * expressly provided under this License.  Any attempt otherwise to copy, modify,
 * sublicense or distribute the Program is void, and will automatically terminate
 * your rights under this License.  However, parties who have received copies, or
 * rights, from you under this License will not have their licenses terminated so
 * long as such parties remain in full compliance.
 *
 * 5. You are not required to accept this License, since you have not signed it.
 * However, nothing else grants you permission to modify or distribute the Program
 * or its derivative works.  These actions are prohibited by law if you do not
 * accept this License.  Therefore, by modifying or distributing the Program (or
 * any work based on the Program), you indicate your acceptance of this License to
 * do so, and all its terms and conditions for copying, distributing or modifying
 * the Program or works based on it.
 *
 * 6. Each time you redistribute the Program (or any work based on the Program),
 * the recipient automatically receives a license from the original licensor to
 * copy, distribute or modify the Program subject to these terms and conditions.
 * You may not impose any further restrictions on the recipients' exercise of the
 * rights granted herein.  You are not responsible for enforcing compliance by
 * third parties to this License.
 *
 * 7. If, as a consequence of a court judgment or allegation of patent
 * infringement or for any other reason (not limited to patent issues), conditions
 * are imposed on you (whether by court order, agreement or otherwise) that
 * contradict the conditions of this License, they do not excuse you from the
 * conditions of this License.  If you cannot distribute so as to satisfy
 * simultaneously your obligations under this License and any other pertinent
 * obligations, then as a consequence you may not distribute the Program at all.
 * For example, if a patent license would not permit royalty-free redistribution
 * of the Program by all those who receive copies directly or indirectly through
 * you, then the only way you could satisfy both it and this License would be to
 * refrain entirely from distribution of the Program.
 *
 * If any portion of this section is held invalid or unenforceable under any
 * particular circumstance, the balance of the section is intended to apply and
 * the section as a whole is intended to apply in other circumstances.
 *
 * It is not the purpose of this section to induce you to infringe any patents or
 * other property right claims or to contest validity of any such claims; this
 * section has the sole purpose of protecting the integrity of the free software
 * distribution system, which is implemented by public license practices.  Many
 * people have made generous contributions to the wide range of software
 * distributed through that system in reliance on consistent application of that
 * system; it is up to the author/donor to decide if he or she is willing to
 * distribute software through any other system and a licensee cannot impose that
 * choice.
 *
 * This section is intended to make thoroughly clear what is believed to be a
 * consequence of the rest of this License.
 *
 * 8. If the distribution and/or use of the Program is restricted in certain
 * countries either by patents or by copyrighted interfaces, the original
 * copyright holder who places the Program under this License may add an explicit
 * geographical distribution limitation excluding those countries, so that
 * distribution is permitted only in or among countries not thus excluded.  In
 * such case, this License incorporates the limitation as if written in the body
 * of this License.
 *
 * 9. The Free Software Foundation may publish revised and/or new versions of the
 * General Public License from time to time.  Such new versions will be similar in
 * spirit to the present version, but may differ in detail to address new problems
 * or concerns.
 *
 * Each version is given a distinguishing version number.  If the Program
 * specifies a version number of this License which applies to it and "any later
 * version", you have the option of following the terms and conditions either of
 * that version or of any later version published by the Free Software Foundation.
 * If the Program does not specify a version number of this License, you may
 * choose any version ever published by the Free Software Foundation.
 *
 * 10. If you wish to incorporate parts of the Program into other free programs
 * whose distribution conditions are different, write to the author to ask for
 * permission.  For software which is copyrighted by the Free Software Foundation,
 * write to the Free Software Foundation; we sometimes make exceptions for this.
 * Our decision will be guided by the two goals of preserving the free status of
 * all derivatives of our free software and of promoting the sharing and reuse of
 * software generally.
 *
 * NO WARRANTY
 *
 * 11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR
 * THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN OTHERWISE
 * STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE
 * PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND
 * PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE,
 * YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
 *
 * 12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL
 * ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE
 * PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
 * GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR
 * INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA
 * BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
 * FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER
 * OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
 *
 * END OF TERMS AND CONDITIONS
 *
 * How to Apply These Terms to Your New Programs
 *
 * If you develop a new program, and you want it to be of the greatest possible
 * use to the public, the best way to achieve this is to make it free software
 * which everyone can redistribute and change under these terms.
 *
 * To do so, attach the following notices to the program.  It is safest to attach
 * them to the start of each source file to most effectively convey the exclusion
 * of warranty; and each file should have at least the "copyright" line and a
 * pointer to where the full notice is found.
 *
 *     One line to give the program's name and a brief idea of what it does.
 *
 *     Copyright (C) <year> <name of author>
 *
 *     This program is free software; you can redistribute it and/or modify it
 *     under the terms of the GNU General Public License as published by the Free
 *     Software Foundation; either version 2 of the License, or (at your option)
 *     any later version.
 *
 *     This program is distributed in the hope that it will be useful, but WITHOUT
 *     ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 *     FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 *     more details.
 *
 *     You should have received a copy of the GNU General Public License along
 *     with this program; if not, write to the Free Software Foundation, Inc., 59
 *     Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 * Also add information on how to contact you by electronic and paper mail.
 *
 * If the program is interactive, make it output a short notice like this when it
 * starts in an interactive mode:
 *
 *     Gnomovision version 69, Copyright (C) year name of author Gnomovision comes
 *     with ABSOLUTELY NO WARRANTY; for details type 'show w'.  This is free
 *     software, and you are welcome to redistribute it under certain conditions;
 *     type 'show c' for details.
 *
 * The hypothetical commands 'show w' and 'show c' should show the appropriate
 * parts of the General Public License.  Of course, the commands you use may be
 * called something other than 'show w' and 'show c'; they could even be
 * mouse-clicks or menu items--whatever suits your program.
 *
 * You should also get your employer (if you work as a programmer) or your school,
 * if any, to sign a "copyright disclaimer" for the program, if necessary.  Here
 * is a sample; alter the names:
 *
 *     Yoyodyne, Inc., hereby disclaims all copyright interest in the program
 *     'Gnomovision' (which makes passes at compilers) written by James Hacker.
 *
 *     signature of Ty Coon, 1 April 1989
 *
 *     Ty Coon, President of Vice
 *
 * This General Public License does not permit incorporating your program into
 * proprietary programs.  If your program is a subroutine library, you may
 * consider it more useful to permit linking proprietary applications with the
 * library.  If this is what you want to do, use the GNU Library General Public
 * License instead of this License.
 *
 *
 * "CLASSPATH" EXCEPTION TO THE GPL
 *
 * Certain source files distributed by Oracle America and/or its affiliates are
 * subject to the following clarification and special exception to the GPL, but
 * only where Oracle has expressly included in the particular source file's header
 * the words "Oracle designates this particular file as subject to the "Classpath"
 * exception as provided by Oracle in the LICENSE file that accompanied this code."
 *
 *     Linking this library statically or dynamically with other modules is making
 *     a combined work based on this library.  Thus, the terms and conditions of
 *     the GNU General Public License cover the whole combination.
 *
 *     As a special exception, the copyright holders of this library give you
 *     permission to link this library with independent modules to produce an
 *     executable, regardless of the license terms of these independent modules,
 *     and to copy and distribute the resulting executable under terms of your
 *     choice, provided that you also meet, for each linked independent module,
 *     the terms and conditions of the license of that module.  An independent
 *     module is a module which is not derived from or based on this library.  If
 *     you modify this library, you may extend this exception to your version of
 *     the library, but you are not obligated to do so.  If you do not wish to do
 *     so, delete this exception statement from your version.
 */
package test.scenegraph.app;

import javafx.geometry.Pos;
import javafx.geometry.HPos;
import javafx.geometry.VPos;
import javafx.geometry.Insets;
import javafx.geometry.Orientation;
import javafx.scene.Node;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Region;
import javafx.scene.layout.TilePane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.VBox;
import javafx.scene.layout.HBox;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.ColumnConstraints;
import javafx.scene.layout.RowConstraints;
import javafx.scene.layout.FlowPane;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.Priority;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Rectangle;
import javafx.scene.paint.Color;
import javafx.scene.control.Button;
import javafx.scene.text.Font;
import javafx.scene.text.Text;

import test.javaclient.shared.BasicButtonChooserApp;
import test.javaclient.shared.PageWithSlots;
import test.javaclient.shared.TestNode;
import test.javaclient.shared.Utils;

/**
 *
 * @author shubov
 */
public class Layout2App extends BasicButtonChooserApp {

    public static enum Pages {

        VBox, HBox, TileShortSet, TileLongSet, StackPane, GridPane, FlowPane,
        BorderPane, AnchorPane, GridPane2
    }
    public static Color nodeColors[] = {Color.RED, Color.YELLOW, Color.BLUE, Color.GREEN, Color.BROWN, Color.MAGENTA};
    private static String IdBlueRegion = "BlueRegion";
    private static String IdGreenRegion = "GreenRegion";
    private static String IdTestButton1 = "IdTestButton1";
    private static String IdRedCircle = "RedCircle";
    private static int zOffset = 0;

    public Layout2App(int width, int height, String title, boolean showAdditionalActionButton) {
        super(width, height, title, showAdditionalActionButton);
    }

    public Layout2App() {
        super(800, 800, "Layout", true); // "true" stands for "additionalActionButton = "
    }

    public void setZOffset(int _offset) {
        zOffset = _offset;
    }
    private static int getZOffset() {
        return zOffset;
    }

    static private interface RegionFiller {

        Pane fill(Pane region);
    }
    private static final boolean withStyle = !Boolean.getBoolean("test.javaclient.jcovbackdoor");

    static Node mylookup(Pane _pane, String _s) {
        for (Node _n : _pane.getChildren()) {
            //System.out.println("compare ["+_s+"] and ["+_n.getId()+"]");
            if (_s.equals(_n.getId())) {
                //System.out.println("return ["+_s+"] , node: ["+_n+"]");
                return _n;
            }
        }
        //System.out.println("return null");
        return null;
    }

    /**
     * fill region with several possible child types:
     *  - empty region (resizeable)
     *  - non-empty region (resizeable)
     *  - circle shape (non-resizeable)
     */
    static private class FillerWithAllNodes implements RegionFiller {

        protected static Pane stFill(Pane region, boolean _withButton) {
            // resizeable node with child
            Pane resizeable = new Pane(); // was: Region x = new Region();
            if (withStyle) {
                resizeable.setStyle("-fx-border-color: blue;");
            }
            resizeable.setId(IdBlueRegion);

            resizeable.getChildren().add(new Circle(4));
            region.getChildren().add(resizeable);

            // resizeable node without child
            resizeable = new Pane();
            if (withStyle) {
                resizeable.setStyle("-fx-border-color: green;");
            }
            resizeable.setId(IdGreenRegion);
            region.getChildren().add(resizeable);

            if (_withButton) {
                Button b1 = new Button("btn");
                b1.setFont(new Font(14));
                b1.setMaxWidth(85);
                b1.setMaxHeight(85);
                b1.setId(IdTestButton1);
                b1.setMaxHeight(200); // 200
                b1.setMaxWidth(200);

                region.getChildren().add(b1);
            }

            FillerWithNonResizeableNodes.stFill(region);

            return region;
        }

        public Pane fill(Pane region) {
            boolean withButton = true;
            return stFill(region, withButton);
        }
    }

    static private class FillerWithAllNodesExceptButton extends FillerWithAllNodes {

        @Override
        public Pane fill(Pane region) {
            boolean withButton = false;
            return stFill(region, withButton);
        }
    }

    /**
     * fill region with non-resizeable childs:
     *  - circle shape (non-resizeable)
     */
    static private class FillerWithNonResizeableNodes implements RegionFiller {

        public static Pane stFill(Pane region) {
            for (int i = 0; i < nodeColors.length; ++i) {
                Circle nonresizeable = new Circle(5 + 3 * ((i) % 4)); //Node
                nonresizeable.setFill(nodeColors[i]);
                region.getChildren().add(nonresizeable);
                nonresizeable.setId("Circle"+nodeColors[i].toString());
                nonresizeable.setTranslateZ(i*getZOffset());

            }
            return region;
        }

        public Pane fill(Pane region) {
            return stFill(region);
        }
    }

    static private class FillerForGrid implements RegionFiller {

        public static Pane stFill(Pane pane) {
            GridPane gridPane = (GridPane) pane;
            for (int i = 1; i < nodeColors.length; ++i) {
                int k = i - 1;
                Circle nonresizeable = new Circle(5 + 3 * ((i) % 4)); //Node
                nonresizeable.setFill(nodeColors[i]);

                GridPane.setColumnIndex(nonresizeable, k % 4);
                GridPane.setRowIndex(nonresizeable, k < 4 ? 0 : 1);
                gridPane.getChildren().add(nonresizeable);
            }

            // add first circle
            Circle nonresizeable0 = new Circle(5 + 3 * ((0) % 4)); //Node
            nonresizeable0.setFill(nodeColors[0]);
            GridPane.setColumnIndex(nonresizeable0, (nodeColors.length - 1) % 4);
            GridPane.setRowIndex(nonresizeable0, (nodeColors.length - 1) < 4 ? 0 : 1);
            gridPane.getChildren().add(nonresizeable0);
            nonresizeable0.setId(IdRedCircle);

            StackPane sp = new StackPane();
            sp.setPadding(new Insets(4,4,4,4));
            Rectangle b2 = new Rectangle(0, 0, 40, 12);
            b2.setFill(Color.GREEN);
            sp.getChildren().add(b2);

            GridPane.setColumnIndex(sp, (nodeColors.length % 4));
            GridPane.setRowIndex(sp, (nodeColors.length < 4)? 0 : 1);
            gridPane.getChildren().add(sp);

            return gridPane;
        }

        public Pane fill(Pane region) {
            return stFill(region);
        }
    }

    // page with VBox layout
    private class slotVboxTestNode extends TestNode {

        protected VBox baseFill(VBox vbox) {
            (new FillerWithAllNodes()).fill(vbox);
            vbox.setPrefSize(80, 240);
            if (withStyle) {
                vbox.setStyle("-fx-border-color: darkgray;");
            }
            return vbox;
        }
    }

    private class slotVboxDefaults extends slotVboxTestNode {
        VBox vbox;
        Region n1;
        @Override
        public Node drawNode() {
            vbox = baseFill(new VBox());

            //Region n1 = (Region)vbox.lookup(IdBlueRegion);
            n1 = (Region)mylookup(vbox,IdBlueRegion);

            // here: first region is resized to it's maximum
            // in this test
            n1.setMaxWidth(10);
            n1.setMaxHeight(20);
            n1.setPrefHeight(10);

            vbox.getChildren().remove(n1);
            HBox hb = new HBox();
            vbox.getChildren().add(0, hb);
            hb.setAlignment(Pos.BOTTOM_RIGHT);
            //hb.setNodeVpos(VPos.BOTTOM);
            hb.getChildren().add(n1);

            // test Priority class
            Priority p[] = Priority.values();
            Priority p2 = Priority.max(p[0], p[1]);
            Priority p3 = Priority.min(p[0], p[1]);
            Priority p4 = Priority.valueOf("SOMETIMES");
            if (p2.equals(p3)) {
                reportGetterFailure("Priority.min/max");
            }
            if (p4 != Priority.SOMETIMES) {
                reportGetterFailure("Priority.valueOf()");
            }
            return vbox;
        }
        @Override
        public void additionalAction() {
            vbox.setPrefSize(70, 240);
            vbox.setSpacing(10);
            Button btn = (Button) mylookup(vbox, IdTestButton1);
            vbox.getChildren().remove(btn);
            vbox.getChildren().add(btn);
            btn.setText("!!!");

            n1.setMaxWidth(30);
            n1.setMaxHeight(20);
            n1.setPrefHeight(20);
        }
    }

    private class slotVboxnodeHpos extends slotVboxTestNode {
        VBox vbox;
        @Override
        public Node drawNode() {
            vbox = baseFill(new VBox());
            vbox.setAlignment(Pos.TOP_RIGHT);
            if (Pos.TOP_RIGHT != vbox.getAlignment()) {
                reportGetterFailure("vboxgetAlignment()");
            }
            return vbox;
        }
        @Override
        public void additionalAction() {
            vbox.setPrefSize(70, 240);
            vbox.setSpacing(10);
            Button btn = (Button) mylookup(vbox, IdTestButton1);
            vbox.getChildren().remove(btn);
            vbox.getChildren().add(btn);
            btn.setText("!!!");

            Region n1 = (Region)mylookup(vbox, IdBlueRegion);
            n1.setMaxWidth(30);
            n1.setMaxHeight(20);
            n1.setPrefHeight(20);
            vbox.getChildren().add(3, new Text(""));
        }
    }

    private class slotVboxcenter extends slotVboxTestNode {

        @Override
        public Node drawNode() {
            VBox vbox = baseFill(new VBox());
            vbox.setAlignment(Pos.TOP_CENTER);
            return vbox;
        }
    }

    private class slotVboxFillwidth extends slotVboxTestNode {

        @Override
        public Node drawNode() {
            VBox vbox = baseFill(new VBox());
            return vbox;
        }
    }

    private class slotVboxPadding extends slotVboxTestNode {

        @Override
        public Node drawNode() {
            VBox vbox = baseFill(new VBox());
            vbox.setPadding(new Insets(15, 15, 15, 15));
            return vbox;
        }
    }

    private class slotVboxSpacingCtor extends slotVboxTestNode {

        @Override
        public Node drawNode() {
            VBox vbox = baseFill(new VBox(5));
            if (5 != vbox.getSpacing()) {
                reportGetterFailure("vbox.getSpacing()");
            }

            return vbox;
        }
    }

    private class slotVboxSpacing extends slotVboxTestNode {

        @Override
        public Node drawNode() {
            VBox vbox = baseFill(new VBox());
            vbox.setSpacing(5);
            if (5 != vbox.getSpacing()) {
                reportGetterFailure("vbox.getSpacing()");
            }

            return vbox;
        }
    }
    private class slotVboxSpacing2 extends slotVboxTestNode {

        @Override
        public Node drawNode() {
            VBox vbox = baseFill(new VBox(10));
            //Region n1 = (Region)vbox.lookup(IdBlueRegion);
            Region n1 = (Region)mylookup(vbox,IdBlueRegion);

            n1.setMaxWidth(10);
            n1.setMaxHeight(20);
            n1.setPrefHeight(10);

            return vbox;
        }
    }
    private class slotVboxNodevbox extends slotVboxTestNode {

        @Override
        public Node drawNode() {
            VBox vbox = baseFill(new VBox());
            return vbox;
        }
    }


    // page with HBox layout
    private class slotHboxTestNode extends TestNode {

        protected HBox baseFill(HBox hbox) {
            (new FillerWithAllNodes()).fill(hbox);
            hbox.setPrefSize(200, 70);
            if (withStyle) {
                hbox.setStyle("-fx-border-color: darkgray;");
            }
            return hbox;
        }
    }
    private class slotHboxDefault extends slotHboxTestNode {
        HBox hbox;

        @Override
        public Node drawNode() {
            hbox = baseFill(new HBox());
            return hbox;
        }
        @Override
        public void additionalAction() {
            Circle redCircle = (Circle) mylookup(hbox, "Circle"+nodeColors[2].toString());
            redCircle.setRadius(20);
            HBox.setMargin(redCircle, new Insets(5,5,5,5));

            Circle xCircle = (Circle) mylookup(hbox, "Circle"+nodeColors[3].toString());
            int iPosition = hbox.getChildren().indexOf(xCircle);
            hbox.getChildren().remove(xCircle);
            VBox vb = new VBox();
            hbox.getChildren().add(iPosition, vb);
            vb.setAlignment(Pos.BOTTOM_CENTER);
            vb.getChildren().add(xCircle);
        }
    }

    private class slotHboxVposTOPHposLeading extends slotHboxTestNode { // VposTOPHposLeading

        @Override
        public Node drawNode() {
            HBox hbox = baseFill(new HBox());
            hbox.setAlignment(Pos.TOP_LEFT);
            if (Pos.TOP_LEFT != hbox.getAlignment()) {
                reportGetterFailure("hbox.getNodeVpos()");
            }
            return hbox;
        }
    }

    private class slotHboxVposBOTTOMHposCenter extends slotHboxTestNode { // VposBOTTOMHposCenter

        @Override
        public Node drawNode() {
            HBox hbox = baseFill(new HBox());
            hbox.setAlignment(Pos.BASELINE_CENTER);

            return hbox;
        }
    }

    private class slotHboxpadding extends slotHboxTestNode { // padding,nodeVPos.CENTER

        @Override
        public Node drawNode() {
            HBox hbox = baseFill(new HBox());
            hbox.setPadding(new Insets(15, 15, 15, 15));
            hbox.setAlignment(Pos.CENTER_LEFT);

            return hbox;
        }
    }

    private class slotHboxspacing extends slotHboxTestNode { // spacing,nodeVpos.PAGE_END

        @Override
        public Node drawNode() {
            HBox hbox = baseFill(new HBox());
            hbox.setAlignment(Pos.BOTTOM_LEFT);
            hbox.setSpacing(5);
            if (5 != hbox.getSpacing()) {
                reportGetterFailure("hbox.getSpacing()");
            }

            return hbox;
        }
    }

    private class slotHboxspacingCtor extends slotHboxTestNode { // spacing Ctor

        @Override
        public Node drawNode() {
            HBox hbox = baseFill(new HBox(5));
            return hbox;
        }
    }

    private class slotHboxnodevpos extends slotHboxTestNode { // nodevpos

        @Override
        public Node drawNode() {
            HBox hbox = baseFill(new HBox());
            hbox.setAlignment(Pos.BOTTOM_LEFT);

            return hbox;
        }
    }

    private class slotBorder extends TestNode {

        protected BorderPane baseFill(BorderPane pane) {
            pane.setPrefSize(180, 190);
            if (withStyle) {
                pane.setStyle("-fx-border-color: darkgray;");
            }
            return pane;
        }
    }
    private class slotBorderDefaults extends slotBorder { // defaults
        BorderPane borderPane;

        @Override
        public Node drawNode() {
            borderPane = baseFill(new BorderPane());

            Circle node1 = new Circle(5 + 3 * ((0) % 4));
            node1.setFill(nodeColors[0]);
            borderPane.setBottom(node1);

            Circle node2 = new Circle(5 + 3 * ((1) % 4));
            node2.setFill(nodeColors[1]);
            borderPane.setTop(node2);

            Circle node3 = new Circle(5 + 3 * ((2) % 4));
            node3.setFill(nodeColors[2]);
            borderPane.setLeft(node3);

            Circle node4 = new Circle(5 + 3 * ((3) % 4));
            node4.setFill(nodeColors[3]);
            borderPane.setRight(node4);

            Circle node5 = new Circle(5 + 3 * ((4) % 4));
            node5.setFill(nodeColors[4]);
            borderPane.setCenter(node5);

            return borderPane;
        }
        @Override
        public void additionalAction() {

            borderPane.setPrefSize(borderPane.getWidth() /2, borderPane.getHeight() /2);

        }

    }

    private class slotBorderDefaults2 extends slotBorder { // defaults2

        BorderPane borderPane;
        @Override
        public Node drawNode() {
            borderPane = baseFill(new BorderPane());

            Circle node1 = new Circle(5 + 3 * ((0) % 4));
            node1.setFill(nodeColors[0]);
            borderPane.setBottom(node1);
            if (node1 != borderPane.getBottom()) {
                reportGetterFailure("borderPane.getBottom()");
            }
            BorderPane.setAlignment(node1, Pos.TOP_CENTER);

            Circle node2 = new Circle(5 + 3 * ((1) % 4));
            node2.setFill(nodeColors[1]);
            borderPane.setTop(node2);
            if (node2 != borderPane.getTop()) {
                reportGetterFailure("borderPane.getTop()");
            }
            BorderPane.setAlignment(node2, Pos.TOP_CENTER);

            Circle node3 = new Circle(5 + 3 * ((2) % 4));
            node3.setFill(nodeColors[2]);
            borderPane.setLeft(node3);
            if (node3 != borderPane.getLeft()) {
                reportGetterFailure("borderPane.getLeft()");
            }
            BorderPane.setAlignment(node3, Pos.BOTTOM_RIGHT);

            Circle node4 = new Circle(5 + 3 * ((3) % 4));
            node4.setFill(nodeColors[3]);
            borderPane.setRight(node4);
            if (node4 != borderPane.getRight()) {
                reportGetterFailure("borderPane.getRight()");
            }
            BorderPane.setAlignment(node4, Pos.BOTTOM_LEFT);

            Circle node5 = new Circle(5 + 3 * ((4) % 4));
            node5.setFill(nodeColors[4]);
            borderPane.setCenter(node5);
            if (node5 != borderPane.getCenter()) {
                reportGetterFailure("borderPane.getCenter()");
            }
            BorderPane.setAlignment(node5, Pos.CENTER_RIGHT);

            return borderPane;
        }
    }

    private class slotBorderWayItWorks extends slotBorder { // wayItWorks

        BorderPane borderPane;
        Button bBottom = new Button("btm");
        Button bTop = new Button("top");
        Button bLeft = new Button("L");
        Button bRight = new Button("R");
        Button bCenter = new Button("c");

        @Override
        public Node drawNode() {
            borderPane = baseFill(new BorderPane());

            for(Button b : new Button[] {bBottom, bTop, bLeft, bRight, bCenter}) {
                b.setMaxSize(200,200);
            }

            BorderPane.clearConstraints(bTop);
            BorderPane.clearConstraints(bBottom);
            BorderPane.clearConstraints(bLeft);
            BorderPane.clearConstraints(bRight);
            BorderPane.clearConstraints(bCenter);

            borderPane.setBottom(bBottom);
            borderPane.setTop(bTop);
            borderPane.setLeft(bLeft);
            borderPane.setRight(bRight);
            borderPane.setCenter(bCenter);

            return borderPane;
        }
        @Override
        public void additionalAction() {

            BorderPane.setMargin(bBottom, new Insets(4,4,4,4));
            BorderPane.setMargin(bTop, new Insets(4,4,4,4));
            BorderPane.setMargin(bLeft, new Insets(4,4,4,4));
            BorderPane.setMargin(bRight, new Insets(4,4,4,4));
            BorderPane.setMargin(bCenter, new Insets(4,4,4,4));

        }
    }

    private class slotBorderchildWithLayout extends slotBorder {

        BorderPane borderPane;
        Button bLeft;

        @Override
        public Node drawNode() {
            borderPane = baseFill(new BorderPane());

            Button bBottom = new Button("btm");
            bBottom.setId(IdTestButton1);
            Button bTop = new Button("top");
            bTop.setId("top");
            bLeft = new Button("L");
            bLeft.setId("left");
            Button bRight = new Button("R");
            bRight.setId("right");
            Button bCenter = new Button("c");

            for (Button btn : new Button[] {bTop, bCenter, bLeft, bRight}) {
                btn.setMaxWidth(150); // 200
                btn.setMinWidth(50); // 200
                btn.setMaxHeight(70);
            }

            bBottom.setMaxWidth(200); // 200
            bBottom.setMaxHeight(200);
            bBottom.setMinHeight(50);

            borderPane.setBottom(bBottom);
            borderPane.setTop(bTop);
            borderPane.setLeft(bLeft);
            borderPane.setRight(bRight);
            borderPane.setCenter(bCenter);

            return borderPane;
        }

        @Override
        public void additionalAction() {
            Button btn = (Button) mylookup(borderPane, IdTestButton1);
            btn.setText("additionalAction");

            btn.setMaxWidth(200); // 200
            btn.setMaxHeight(200);
            btn.setMinHeight(5);

            Button btnTop = (Button) mylookup(borderPane, "top");
            btn.setText("additionalAction");

            btnTop.setMaxWidth(70); // 200
            btnTop.setMinWidth(70); // 200
            BorderPane.setAlignment(bLeft, Pos.BOTTOM_LEFT);
        }
    }

    private class slotStack extends TestNode {

        protected StackPane baseFill(StackPane pane) {
            pane.setPrefSize(130, 130);
            (new FillerWithAllNodes()).fill(pane);
            if (withStyle) {
                pane.setStyle("-fx-border-color: darkgray;");
            }
            return pane;
        }
    }

    private class slotStackDefaults extends slotStack { // defaults

        StackPane stackPane;

        @Override
        public Node drawNode() {
            stackPane = baseFill(new StackPane());
            return stackPane;
        }

        @Override
        public void additionalAction() {
            Button btn = (Button) mylookup(stackPane, IdTestButton1);


            // TODO
            btn.setText("\n\n Yess!!!");
            btn.setMaxWidth(70);
            btn.setMaxHeight(40);
            double d1 = btn.getBoundsInLocal().getHeight();
            double d3 = btn.getLayoutY();
            double d4 = btn.getScaleY();
            double d2 = btn.getMaxHeight();
        }
    }

    private class slotStackPadding extends slotStack { // padding

        StackPane stackPane;

        @Override
        public Node drawNode() {
            stackPane = baseFill(new StackPane());
            stackPane.setPadding(new Insets(15, 15, 15, 15));
            return stackPane;
        }
    }

    private class slotStacknodeVpos extends slotStack { // nodeVpos

        StackPane stackPane;

        @Override
        public Node drawNode() {
            stackPane = baseFill(new StackPane());
            stackPane.setAlignment(Pos.BOTTOM_CENTER);

            return stackPane;
        }
        @Override
        public void additionalAction() {
            Circle cc2 = (Circle) mylookup(stackPane, "Circle"+nodeColors[2].toString());
            Circle cc3 = (Circle) mylookup(stackPane, "Circle"+nodeColors[3].toString());
            Circle cc4 = (Circle) mylookup(stackPane, "Circle"+nodeColors[4].toString());

            StackPane.setMargin(cc2, new Insets (20,20,20,20));
            StackPane.setMargin(cc3, new Insets (40,40,40,40));
            StackPane.setMargin(cc4, new Insets (10,50,10,50));

        }
    }

    private class slotStacknodeHposRight extends slotStack { // nodeHposRight

        StackPane stackPane;

        @Override
        public Node drawNode() {
            stackPane = baseFill(new StackPane());
            stackPane.setAlignment(Pos.CENTER_RIGHT);
            return stackPane;
        }
    }

    private class slotStacknodeHposLeft extends slotStack { // nodeHposLeft

        StackPane stackPane;

        @Override
        public Node drawNode() {
            stackPane = baseFill(new StackPane());
            stackPane.setAlignment(Pos.CENTER_LEFT);
            /*
            if (HPos.LEFT != stackPane.getNodeHpos()) {
                reportGetterFailure("stackPane.getNodeHpos()");
            }
             *
             */
            return stackPane;
        }
    }

    private class slotStacknodeHposTrailing extends slotStack { // nodeHposTrailing

        StackPane stackPane;

        @Override
        public Node drawNode() {
            stackPane = baseFill(new StackPane());
            stackPane.setAlignment(Pos.BOTTOM_RIGHT);
            /* .setNodeHpos(HPos.TRAILING); TODO
            HPos hpos = stackPane.getNodeHpos();
            if (hpos != HPos.TRAILING) {
                reportGetterFailure("getNodeHpos");
            }
             *
             */
            return stackPane;
        }
    }

    private class slotGrid extends TestNode {

        protected GridPane baseFill(GridPane pane) {
            pane.setPrefSize(130, 130);
            pane.setGridLinesVisible(true);
            FillerForGrid.stFill(pane);
            if (withStyle) {
                pane.setStyle("-fx-border-color: darkgray;");
            }
            return pane;
        }
    }

    private class slotGriddefaults extends slotGrid { // defaults

        GridPane pane;

        @Override
        public Node drawNode() {
            pane = baseFill(new GridPane());
            pane.setGridLinesVisible(false);
            if (pane.isGridLinesVisible()) {
                reportGetterFailure("GridPane.setGridLinesVisible(false)");
            }
            return pane;
        }
    }

    private class slotGridHVgap extends slotGrid { // HVgap

        GridPane pane;

        @Override
        public Node drawNode() {
            pane = baseFill(new GridPane());
            pane.setVgap(10);
            if (10 != pane.getVgap()) {
                reportGetterFailure("GridPane.getVgap()");
            }
            pane.setHgap(5);
            if (5 != pane.getHgap()) {
                reportGetterFailure("GridPane.getHgap()");
            }
            return pane;
        }
    }

    private class slotGridpadding extends slotGrid { // padding

        GridPane pane;

        @Override
        public Node drawNode() {
            pane = baseFill(new GridPane());
            pane.setPadding(new Insets(15, 15, 15, 15));
            pane.setAlignment(Pos.TOP_CENTER);
            if (Pos.TOP_CENTER != pane.getAlignment()) {
                reportGetterFailure("GridPane.getAlignment()");
            }
            return pane;
        }
    }

    private class slotGridnodeVpos extends slotGrid { // nodeVpos

        GridPane pane;

        @Override
        public Node drawNode() {
            pane = baseFill(new GridPane());
            pane.setAlignment(Pos.BOTTOM_CENTER);
            return pane;
        }
    }

    private class slotGridnodeHposRight extends slotGrid { // nodeHposRight

        GridPane pane;

        @Override
        public Node drawNode() {
            pane = baseFill(new GridPane());
            pane.setAlignment(Pos.CENTER_RIGHT);

            /* todo
            pane.setNodeHpos(HPos.RIGHT);
            if (HPos.RIGHT != pane.getNodeHpos()) {
                reportGetterFailure("GridPane.getNodeHpos()");
            }
             *
             */
            return pane;
        }
    }

    private class slotGridnodeHposCenter extends slotGrid { // nodeHposCenter

        GridPane pane;

        @Override
        public Node drawNode() {
            pane = baseFill(new GridPane());
            pane.setAlignment(Pos.CENTER);
            return pane;
        }
    }

    private class slotGridnodeHposTrailing extends slotGrid { // nodeHposTrailing

        GridPane pane;

        @Override
        public Node drawNode() {
            pane = baseFill(new GridPane());
            pane.setAlignment(Pos.CENTER_RIGHT);

            StackPane sp = new StackPane();
            sp.setPadding(new Insets(4,4,4,4));
            Rectangle b2 = new Rectangle(0, 0, 14, 16);
            b2.setFill(Color.GREEN);
            sp.getChildren().add(b2);

            GridPane.setRowIndex(sp, 0);
            GridPane.setColumnIndex(sp, 4);
            GridPane.setRowSpan(sp, 2);
            pane.getChildren().add(sp);

            return pane;
        }
    }

    private class slotGridnodeColspan1 extends slotGrid { // nodeColspan1

        GridPane pane;

        @Override
        public Node drawNode() {
            pane = baseFill(new GridPane());

            StackPane sp = new StackPane();
            sp.setPadding(new Insets(4,4,4,4));
            Rectangle b2 = new Rectangle(0, 0, 60, 16);
            b2.setFill(Color.GREEN);
            sp.getChildren().add(b2);

            GridPane.setRowIndex(sp, 2);
            GridPane.setColumnIndex(sp, 2);
            GridPane.setColumnSpan(sp, 2);
            pane.getChildren().add(sp);

            pane.setAlignment(Pos.TOP_CENTER);
            return pane;
        }
    }

    private class slotGridnodeColspan2 extends slotGrid { // nodeColspan1

        private GridPane pane;

        @Override
        public Node drawNode() {
            pane = new GridPane();
            if (withStyle) {
                pane.setStyle("-fx-border-color: darkgray;");
            }
            pane.setGridLinesVisible(true);

            Circle c1 = new Circle(8);
            GridPane.setHalignment(c1,HPos.LEFT); //.LEADING);
            GridPane.setConstraints(c1, 0, 0);

            Circle c2 = new Circle(8);
            GridPane.setConstraints(c2, 0, 1);
            GridPane.setHalignment(c2,HPos.RIGHT); //.TRAILING

            Circle c3 = new Circle(8);
            GridPane.setConstraints(c3, 2, 2);
            GridPane.setHalignment(c3,HPos.RIGHT);
            GridPane.setValignment(c3,VPos.BOTTOM);

            StackPane sp = new StackPane();
            sp.setPadding(new Insets(4,4,4,4));
            Rectangle b2 = new Rectangle(0, 0, 60, 16);
            b2.setFill(Color.GREEN);
            sp.getChildren().add(b2);
            GridPane.setConstraints(sp, 1, 0,2,2);

            StackPane sp2 = new StackPane();
            sp2.setPadding(new Insets(4,4,4,4));
            Rectangle b2a = new Rectangle(0, 0, 16, 60);
            b2a.setFill(Color.RED);
            sp2.getChildren().add(b2a);
            GridPane.setMargin(sp2, new Insets(5,5,5,5));
            GridPane.setConstraints(sp2, 0, 0,1,3);

            Circle c4 = new Circle(8);
            GridPane.setConstraints(c4, 1, 2);
            GridPane.setValignment(c4,VPos.TOP);

            StackPane sp3 = new StackPane();
            Pane  p0 = new Pane();
            p0.setStyle("-fx-border-color: red;");
            sp3.setPadding(new Insets(2,2,2,2));
            sp3.getChildren().add(p0);
            Circle c5 = new Circle(8);
            sp3.getChildren().add(c5);
            GridPane.setMargin(sp3, new Insets(5,5,5,5));
            GridPane.setConstraints(sp3, 1, 3, 2,1, HPos.CENTER, VPos.BASELINE);

            StackPane sp4 = new StackPane();
            Pane  p1 = new Pane();
            p1.setStyle("-fx-border-color: blue;");
            sp4.setPadding(new Insets(2,2,2,2));
            sp4.getChildren().add(p1);
            Circle c6 = new Circle(8);
            sp4.getChildren().add(c6);
            GridPane.setConstraints(sp4, 0, 4, 2,1, HPos.LEFT, VPos.CENTER, Priority.SOMETIMES,Priority.SOMETIMES,new Insets(5,5,5,5));

            Circle c7 = new Circle(8);
            GridPane.setConstraints(c7, 2, 4);
            GridPane.setValignment(c7,VPos.CENTER);

            pane.getChildren().addAll(c1,c2,c3,c4, sp, sp2);
            pane.getChildren().add(sp3);
            pane.getChildren().add(sp4);
            pane.getChildren().add(c7);

            return pane;
        }
    }

    private class slotGridnodeColspan3 extends slotGrid { // nodeColspan1

        private GridPane pane;

        @Override
        public Node drawNode() {
            pane = new GridPane();
            if (withStyle) {
                pane.setStyle("-fx-border-color: darkgray;");
            }
            pane.setGridLinesVisible(true);

            pane.getRowConstraints().add(new RowConstraints() {
                {
                    setMinHeight(35);
                    this.setValignment(VPos.TOP);
                }
            });

            pane.getRowConstraints().add(new RowConstraints() {
                {
                    setMinHeight(35);
                    setValignment(VPos.BOTTOM);
                }
            });

            pane.getRowConstraints().add(new RowConstraints() {
                {
                    setMinHeight(35);
                    setValignment(VPos.BOTTOM);
                }
            });
            pane.getRowConstraints().add(new RowConstraints() {
                {
                    setMinHeight(35);
                    setValignment(VPos.BOTTOM);
                }
            });


            Circle c1 = new Circle(8);
            GridPane.setConstraints(c1, 0, 0);
            c1.setFill(Color.RED);

            Circle c2 = new Circle(8);
            GridPane.setConstraints(c2, 1, 0);
            c2.setFill(Color.BLUE);

            Circle c3 = new Circle(8);
            GridPane.setConstraints(c3, 2, 0);
            c3.setFill(Color.GREEN);

            StackPane sp2 = new StackPane();
            sp2.setPadding(new Insets(4, 4, 4, 4));
            Rectangle b2a = new Rectangle(0, 0, 16, 40);
            b2a.setFill(Color.RED);
            sp2.getChildren().add(b2a);
            GridPane.setMargin(sp2, new Insets(5, 5, 5, 5));
            GridPane.setConstraints(sp2, 3, 0, 2, 2);

            pane.getChildren().addAll(c1, c2, c3, sp2);

            return pane;
        }
    }

    private class slotGridColumnInfo extends slotGrid { // nodeColspan1

        private GridPane pane;

        @Override
        public Node drawNode() {
            pane = new GridPane();
            if (withStyle) {
                pane.setStyle("-fx-border-color: darkgray;");
            }
            pane.setGridLinesVisible(true);
            pane.getColumnConstraints().add(new ColumnConstraints(){{setMinWidth(25);this.setHalignment(HPos.CENTER);}});
            //pane.getColumnInfo().add(new GridColumnInfo(){{setMinWidth(25);this.setHalignment(HPos.CENTER);}});
            pane.getColumnConstraints().add(new ColumnConstraints(){{setMinWidth(25);setHalignment(HPos.LEFT);}});
            pane.getColumnConstraints().add(new ColumnConstraints(){{setMinWidth(25);setHalignment(HPos.RIGHT);}});
            pane.getColumnConstraints().add(new ColumnConstraints(){{setMinWidth(25);setHalignment(HPos.RIGHT);}});

            Circle c1 = new Circle(8);
            GridPane.setConstraints(c1, 0, 0);
            c1.setFill(Color.RED);

          

            Circle c2 = new Circle(8);
            GridPane.setConstraints(c2, 1, 0);
            c2.setFill(Color.BLUE);

            Circle c3 = new Circle(8);
            GridPane.setConstraints(c3, 2, 0);
            c3.setFill(Color.GREEN);

            StackPane sp2 = new StackPane();
            sp2.setPadding(new Insets(4,4,4,4));
            Rectangle b2a = new Rectangle(0, 0, 40, 16);
            b2a.setFill(Color.RED);
            sp2.getChildren().add(b2a);
            GridPane.setMargin(sp2, new Insets(5,5,5,5));
            GridPane.setConstraints(sp2, 0, 3,2,2);

            pane.getChildren().addAll(c1,c2,c3, sp2);

            return pane;
        }
    }

    private class slotGridPercent1 extends slotGrid { // nodeColspan1

        private GridPane pane;

        @Override
        public Node drawNode() {
            pane = new GridPane();
            if (withStyle) {
                pane.setStyle("-fx-border-color: blue;");
            }
            pane.setGridLinesVisible(true);

            ColumnConstraints column1 = new ColumnConstraints();
            column1.setPercentWidth(50);//.setWidthPercent(50);
            RowConstraints row1 = new RowConstraints();
            row1.setPercentHeight(50);
            pane.getColumnConstraints().addAll(column1);
            pane.getRowConstraints().add(row1);

            Circle c1 = new Circle(8);
            GridPane.setConstraints(c1, 0, 0);
            c1.setFill(Color.RED);

            Circle c2 = new Circle(8);
            GridPane.setConstraints(c2, 1, 1);
            c2.setFill(Color.BLUE);

            Circle c3 = new Circle(8);
            GridPane.setConstraints(c3, 2, 2);
            c3.setFill(Color.GREEN);
            pane.getChildren().addAll(c1,c2,c3);
/*
            StackPane sp2 = new StackPane();
            sp2.setPadding(new Insets(4,4,4,4));
            Rectangle b2a = new Rectangle(0, 0, 40, 16);
            b2a.setFill(Color.RED);
            sp2.getChildren().add(b2a);
            GridPane.setMargin(sp2, new Insets(5,5,5,5));
            GridPane.setConstraints(sp2, 0, 3,2,2);
            
            pane.getChildren().addAll(sp2);
*/

            return pane;
        }
    }


    private class slotGridRowConstraint1 extends slotGrid {

        private GridPane pane;

        @Override
        public Node drawNode() {
            pane = new GridPane();
            if (withStyle) {
                pane.setStyle("-fx-border-color: darkgray;");
            }
            pane.setGridLinesVisible(true);

            pane.getRowConstraints().add(new RowConstraints(40) );
            pane.getRowConstraints().add(new RowConstraints(30,40,60) );
            pane.getRowConstraints().add(new RowConstraints(30,40,60, Priority.ALWAYS, VPos.BOTTOM, true) );

            Circle c1 = new Circle(8);
            GridPane.setConstraints(c1, 0, 0);
            c1.setFill(Color.RED);

            Circle c2 = new Circle(8);
            GridPane.setConstraints(c2, 1, 0);
            c2.setFill(Color.BLUE);

            Circle c3 = new Circle(8);
            GridPane.setConstraints(c3, 2, 0);
            c3.setFill(Color.GREEN);

            Circle c3a = new Circle(8);
            GridPane.setConstraints(c3a, 1, 1);
            c3a.setFill(Color.GREEN);

            Circle c3b = new Circle(8);
            GridPane.setConstraints(c3b, 2, 2);
            c3b.setFill(Color.GREEN);

            pane.getChildren().addAll( c3a, c3b);

            StackPane sp2 = new StackPane();
            sp2.setPadding(new Insets(4, 4, 4, 4));
            Rectangle b2a = new Rectangle(0, 0, 16, 40);
            b2a.setFill(Color.RED);
            sp2.getChildren().add(b2a);
            GridPane.setMargin(sp2, new Insets(5, 5, 5, 5));
            GridPane.setConstraints(sp2, 3, 0, 2, 2);

            pane.getChildren().addAll(c1, c2, c3, sp2);

            return pane;
        }
    }

    private class slotGridRowConstraint2 extends slotGrid {

        private GridPane pane;

        @Override
        public Node drawNode() {
            pane = new GridPane();
            if (withStyle) {
                pane.setStyle("-fx-border-color: darkgray;");
            }
            pane.setPrefSize(130, 130);

            pane.setGridLinesVisible(false);

            RowConstraints rc1 = new RowConstraints();
            rc1.setFillHeight(false);
            pane.getRowConstraints().add(rc1);

            Circle c1 = new Circle(8);
            GridPane.setConstraints(c1, 0, 0);
            c1.setFill(Color.RED);


            StackPane sp2 = new StackPane();
            sp2.setPadding(new Insets(2, 2, 2, 2));
            sp2.setPrefSize(10,10);
            sp2.setMaxSize(50,50);
            sp2.setStyle("-fx-border-color: red;");
            GridPane.setHalignment(sp2,HPos.CENTER);
            GridPane.setValignment(sp2,VPos.CENTER);


            Rectangle r1 = new Rectangle(12,110);
            GridPane.setConstraints(r1, 1, 0);
            r1.setFill(Color.BLUE);

            Rectangle r2 = new Rectangle(110,12);
            GridPane.setConstraints(r2, 0, 1);
            r2.setFill(Color.GREEN);

            pane.getChildren().addAll(sp2, r1, r2);

            return pane;
        }
    }

    private class slotAnchor extends TestNode {
        protected AnchorPane baseFill(AnchorPane pane) {
            pane.setPrefSize(130, 130);
            (new FillerWithAllNodes()).fill(pane);
            if (withStyle) {
                pane.setStyle("-fx-border-color: darkgray;");
            }
            return pane;
        }
    }

    private class slotAnchorDefaults extends slotAnchor {
        AnchorPane pane;

        @Override
        public Node drawNode() {
            pane = baseFill(new AnchorPane());
            return pane;
        }
        @Override
        public void additionalAction() {
            pane.setPrefSize(120, 120);
        }
    }

    private class slotAnchor2 extends slotAnchor {

        AnchorPane pane;

        @Override
        public Node drawNode() {
            pane = baseFill(new AnchorPane());
            Button btn = (Button) mylookup(pane, IdTestButton1);
            Circle cc2 = (Circle) mylookup(pane, "Circle"+nodeColors[2].toString());
            Circle cc3 = (Circle) mylookup(pane, "Circle"+nodeColors[3].toString());
            Circle cc4 = (Circle) mylookup(pane, "Circle"+nodeColors[4].toString());

            AnchorPane.setBottomAnchor(btn, 20d);
            AnchorPane.setTopAnchor(cc2, 10d);
            AnchorPane.setLeftAnchor(cc3, 10d);
            AnchorPane.setRightAnchor(cc4, 20d);

            if (20d != AnchorPane.getBottomAnchor(btn)) {
                reportGetterFailure("AnchorPane.getBottomAnchor()");
            }
            if (10d != AnchorPane.getTopAnchor(cc2)) {
                reportGetterFailure("AnchorPane.getTopAnchor()");
            }
            if (10d != AnchorPane.getLeftAnchor(cc3)) {
                reportGetterFailure("AnchorPane.getLeftAnchor()");
            }
            if (20d != AnchorPane.getRightAnchor(cc4)) {
                reportGetterFailure("AnchorPane.getRightAnchor()");
            }

            AnchorPane.clearConstraints(btn);
            AnchorPane.clearConstraints(cc2);
            AnchorPane.clearConstraints(cc3);
            AnchorPane.clearConstraints(cc4);

            if (null != AnchorPane.getBottomAnchor(btn)) {
                reportGetterFailure("AnchorPane.clearConstraints()");
            }
            if (null != AnchorPane.getTopAnchor(cc2)) {
                reportGetterFailure("AnchorPane.clearConstraints()");
            }
            if (null != AnchorPane.getLeftAnchor(cc3)) {
                reportGetterFailure("AnchorPane.clearConstraints()");
            }
            if (null != AnchorPane.getRightAnchor(cc4)) {
                reportGetterFailure("AnchorPane.clearConstraints()");
            }
            AnchorPane.setBottomAnchor(btn, 20d);
            AnchorPane.setTopAnchor(cc2, 10d);
            AnchorPane.setLeftAnchor(cc3, 10d);
            AnchorPane.setRightAnchor(cc4, 20d);

            VBox vbox = new VBox();
            vbox.getChildren().add(pane);
            return vbox;
        }
        @Override
        public void additionalAction() {
            pane.setPrefSize(70, 150);
            Button btn = (Button) mylookup(pane, IdTestButton1);
            pane.getChildren().remove(btn);
            pane.getChildren().add(btn);
            btn.setManaged(false);
        }
    }

    private class slotFlow extends TestNode {

        protected FlowPane baseFill(FlowPane pane) {
            pane.setPrefSize(130, 130);
            (new FillerWithAllNodes()).fill(pane);
            if (withStyle) {
                pane.setStyle("-fx-border-color: darkgray;");
            }
            return pane;
        }
    }

    private class slotFlowdefaults extends slotFlow { // defaults

        FlowPane pane;

        @Override
        public Node drawNode() {
            pane = baseFill(new FlowPane());
            return pane;
        }
    }

    private class slotFlowwrapLen extends slotFlow { // wrapLen

        FlowPane pane;

        @Override
        public Node drawNode() {
            pane = baseFill(new FlowPane());
            pane.setPrefWrapLength(10);
            if (10 != pane.getPrefWrapLength()) {
                reportGetterFailure("FlowPane.getWrapLength()");
            }
            return pane;
        }
    }

    private class slotFlowpadding extends slotFlow { // padding

        FlowPane pane;

        @Override
        public Node drawNode() {
            pane = baseFill(new FlowPane());
            pane.setPadding(new Insets(15, 15, 15, 15));
            return pane;
        }
    }

    private class slotFlownodeVposBottom extends slotFlow { // nodeVposBottom

        FlowPane pane;

        @Override
        public Node drawNode() {
            pane = baseFill(new FlowPane());
            pane.setRowValignment(VPos.BOTTOM);
            return pane;
        }
    }

    private class slotFlownodeVposTop extends slotFlow { // nodeVposTop

        FlowPane pane;

        @Override
        public Node drawNode() {
            pane = baseFill(new FlowPane());
            pane.setRowValignment(VPos.TOP);
            return pane;
        }
    }

    private class slotFlowGap5 extends slotFlow { // Gap5

        FlowPane pane;

        @Override
        public Node drawNode() {
            pane = baseFill(new FlowPane());
            pane.setHgap(10);
            if (pane.getHgap() != 10) {
                reportGetterFailure("FlowPane.getHgap()");
            }

            pane.setColumnHalignment(HPos.LEFT);
            pane.setRowValignment(VPos.TOP);
            pane.setAlignment(Pos.BOTTOM_LEFT);//.setVpos(VPos.BOTTOM);
            if (pane.getAlignment() != Pos.BOTTOM_LEFT) {
                reportGetterFailure("FlowPane.getAlignment()");
            }

            return pane;
        }
    }

    private class slotFlownodeHposRight extends slotFlow { // nodeHposRight

        FlowPane pane;

        @Override
        public Node drawNode() {
            pane = baseFill(new FlowPane());
            pane.setAlignment(Pos.TOP_CENTER);
            if (pane.getAlignment() != Pos.TOP_CENTER) {
                reportGetterFailure("FlowPane.getAlignment()");
            }
            return pane;
        }
    }

    private class slotFlownodeHposRight2 extends slotFlow { // nodeHposRight2

        FlowPane pane;

        @Override
        public Node drawNode() {
            pane = baseFill(new FlowPane());
            pane.setAlignment(Pos.TOP_RIGHT);
            return pane;
        }
    }

    private class slotFlowvertical_1 extends slotFlow { // vertical_1

        FlowPane pane;

        @Override
        public Node drawNode() {
            for (Orientation or : Orientation.values()) {
                if (Orientation.HORIZONTAL != or && Orientation.VERTICAL != or ) {
                    reportGetterFailure("Orientation.values()");
                }
                if (Orientation.valueOf(or.name().toString()) != or) {
                    reportGetterFailure("Orientation.valueOf()");
                }
            }
            pane = baseFill(new FlowPane(Orientation.VERTICAL));  // "true" here stands for setVertical(true)
            pane.setVgap(20);
            if (pane.getVgap() != 20) {
                reportGetterFailure("FlowPane.getVgap()");
            }
            pane.setAlignment(Pos.valueOf(Pos.BOTTOM_LEFT.toString()));
            pane.setRowValignment(VPos.valueOf(VPos.BOTTOM.toString()));
            pane.setColumnHalignment(HPos.valueOf(HPos.LEFT.toString()));
            /* todo
            pane.setVpos(VPos.BOTTOM);
            pane.setNodeVpos(VPos.TOP);
            if (false == pane.isVertical()) {
                reportGetterFailure("FlowPane.isVertical()");
            }
             *
             */
            return pane;
        }
    }

    private class slotFlowvertical_2 extends slotFlow { // vertical_2

        FlowPane pane;

        @Override
        public Node drawNode() {
            pane = baseFill(new FlowPane(Orientation.VERTICAL, 10, 20));  // "true" here stands for setVertical(true)
            pane.setOrientation(Orientation.VERTICAL);
            pane.setColumnHalignment(HPos.RIGHT);
            /* todo
            pane.setVpos(VPos.BASELINE);
            pane.setNodeHpos(HPos.RIGHT);
            if (pane.getNodeHpos() != HPos.RIGHT) {
                reportGetterFailure("FlowPane.getNodeHpos()");
            }
             *
             */
            return pane;
        }
    }

    private class slotFlowhgapvgapCtor extends slotFlow { // hgap-vgap Ctor

        FlowPane pane;

        @Override
        public Node drawNode() {
            pane = baseFill(new FlowPane(10, 20));
            pane.setOrientation(Orientation.VERTICAL);
            pane.setAlignment(Pos.CENTER_LEFT);
            pane.setRowValignment(VPos.BOTTOM);
            pane.setColumnHalignment(HPos.RIGHT);
            return pane;
        }
    }

    private class slotTile extends TestNode {

        final RegionFiller filler;

        public slotTile(final RegionFiller a_filler) {
            filler = a_filler;
        }

        protected TilePane baseFill(TilePane pane) {
            filler.fill(pane);
            pane.setPrefSize(160, 160);
            if (withStyle) {
                pane.setStyle("-fx-border-color: darkgray;");
            }
            return pane;

        }
    }

    private class slotTiledefaults extends slotTile { // defaults

        TilePane tilePane;

        public slotTiledefaults(final RegionFiller a_filler) {
            super(a_filler);
        }

        @Override
        public Node drawNode() {
            tilePane = baseFill(new TilePane());
            if (Orientation.VERTICAL == tilePane.getOrientation()) {
                reportGetterFailure("tilePane.isVertical()");
            }
            return tilePane;
        }
        @Override
        public void additionalAction() {
            Circle cc2 = (Circle) mylookup(tilePane, "Circle"+nodeColors[2].toString());
            Circle cc3 = (Circle) mylookup(tilePane, "Circle"+nodeColors[3].toString());
            Button btn = (Button) mylookup(tilePane, IdTestButton1);

            tilePane.getChildren().remove(cc2);
            tilePane.getChildren().remove(cc3);
            tilePane.getChildren().remove(btn);
            tilePane.setPrefSize(90, 90);
            tilePane.setOrientation(Orientation.VERTICAL);
        }
    }

    private class slotTilegap extends slotTile { // gap

        TilePane tilePane;

        public slotTilegap(final RegionFiller a_filler) {
            super(a_filler);
        }

        @Override
        public Node drawNode() {
            tilePane = baseFill(new TilePane());
            tilePane.setHgap(5);
            if (5 != tilePane.getHgap()) {
                //TODO: we don't verify here that hgap is applied to graphic
                reportGetterFailure("tilePane.getHgap()");
            }

            tilePane.setVgap(20);
            if (20 != tilePane.getVgap()) {
                //TODO: we don't verify here that vgap is applied to graphic
                reportGetterFailure("tilePane.getVgap()");
            }

            return tilePane;
        }
        @Override
        public void additionalAction() {
            Region n1 = (Region) mylookup(tilePane, IdBlueRegion);
            Region n2 = (Region) mylookup(tilePane, IdGreenRegion);
            Button btn = (Button) mylookup(tilePane, IdTestButton1);

            if (null != n1 && null !=n2 && null!= btn) {
                TilePane.setMargin(n1, new Insets(4,4,4,4));
                TilePane.setMargin(n2, new Insets(0,-4,-4,-4));
                tilePane.getChildren().remove(btn);
            }
        }
    }

    private class slotTilegapCtor extends slotTile { // gapCtor

        TilePane tilePane;

        public slotTilegapCtor(final RegionFiller a_filler) {
            super(a_filler);
        }

        @Override
        public Node drawNode() {
            tilePane = baseFill(new TilePane(5, 15));
            return tilePane;
        }
    }

    private class slotTilegapCtor2 extends slotTile { // gapCtor2

        TilePane tilePane;

        public slotTilegapCtor2(final RegionFiller a_filler) {
            super(a_filler);
        }

        @Override
        public Node drawNode() {
            tilePane = baseFill(new TilePane(Orientation.VERTICAL, 5, 15));
            tilePane.setAlignment(Pos.TOP_LEFT);

            return tilePane;
        }
    }

    private class slotTilepaddingVert extends slotTile { // paddingVert

        TilePane tilePane;

        public slotTilepaddingVert(final RegionFiller a_filler) {
            super(a_filler);
        }

        @Override
        public Node drawNode() {
            tilePane = baseFill(new TilePane());
            tilePane.setPadding(new Insets(15, 15, 15, 15));
            tilePane.setOrientation(Orientation.VERTICAL);

            tilePane.setAlignment(Pos.BOTTOM_LEFT);;
            if (Pos.BOTTOM_LEFT != tilePane.getAlignment()) {
                reportGetterFailure("tilePane.getVpos()");
            }

            tilePane.setPrefRows(2);// was:.setRows(2);
            if (2 != tilePane.getPrefRows()) {
                reportGetterFailure("tilePane.getRows()");
            }

            return tilePane;
        }
    }

    private class slotTileverticalCtor extends slotTile { // vertical Ctor

        TilePane tilePane;

        public slotTileverticalCtor(final RegionFiller a_filler) {
            super(a_filler);
        }

        @Override
        public Node drawNode() {
            tilePane = baseFill(new TilePane(Orientation.VERTICAL)); // true == vertical
            tilePane.setAlignment(Pos.TOP_LEFT);//.setHpos(HPos.LEADING);
            if (Pos.TOP_LEFT != tilePane.getAlignment()) {
                reportGetterFailure("tilePane.getAlignment()");
            }


            if (Orientation.VERTICAL != tilePane.getOrientation()) {
                reportGetterFailure("tilePane.isVertical() 2nd tst");
            }
            return tilePane;
        }
    }

    private class slotTileVpos extends slotTile { // Vpos

        TilePane tilePane;

        public slotTileVpos(final RegionFiller a_filler) {
            super(a_filler);
        }

        @Override
        public Node drawNode() {
            tilePane = baseFill(new TilePane());
            tilePane.setAlignment(Pos.BOTTOM_LEFT);
            return tilePane;
        }
    }

    private class slotTileHpos extends slotTile { // Hpos

        TilePane tilePane;

        public slotTileHpos(final RegionFiller a_filler) {
            super(a_filler);
        }

        @Override
        public Node drawNode() {
            tilePane = baseFill(new TilePane());
            tilePane.setAlignment(Pos.TOP_RIGHT);
            return tilePane;
        }
    }

    private class slotTilecenter extends slotTile { // center

        TilePane tilePane;

        public slotTilecenter(final RegionFiller a_filler) {
            super(a_filler);
        }

        @Override
        public Node drawNode() {
            tilePane = baseFill(new TilePane()); // true == vertical
            tilePane.setPrefColumns(3);
            tilePane.setAlignment(Pos.BOTTOM_CENTER);
            for (Node _n : tilePane.getChildren()) {
                TilePane.setAlignment(_n, Pos.BOTTOM_RIGHT);
            }
            /* todo
            tilePane.setNodeHpos(HPos.RIGHT);
            if (HPos.RIGHT != tilePane.getNodeHpos()) {
                reportGetterFailure("tilePane.getNodeHpos()");
            }
            tilePane.setNodeVpos(VPos.BOTTOM);
            if (VPos.BOTTOM != tilePane.getNodeVpos()) {
                reportGetterFailure("tilePane.getNodeVpos()");
            }
            */
            tilePane.setPrefColumns(3); // was: .setColumns(3);
            if (3 != tilePane.getPrefColumns()) {
                reportGetterFailure("tilePane.getColumns()");
            }

            return tilePane;
        }
        @Override
        public void additionalAction() {
            TestAsRegion(tilePane);
        }
    }

    void TestAsRegion(Region region) {
        double rHeight = region.getHeight();
        double rWidth = region.getWidth();
        boolean isResizeable = region.isResizable();
        if (isResizeable) {
            region.resize(rWidth-20, rHeight-20);
        }

        Insets insets = region.getPadding();
        region.setPadding(insets);

        boolean isSnapToPixel = region.isSnapToPixel();
        region.setSnapToPixel(isSnapToPixel);
    }

    public TestNode setup() {
        System.out.println("java.library.path=" + System.getProperty("java.library.path"));
        //Button bbb = new Button("button1");
        TestNode rootTestNode = new TestNode();

        final int heightPageContentPane = 800;
        final int widthPageContentPane = 800;

        // ======== VBOX =================
        final PageWithSlots vboxPage = new PageWithSlots(Pages.VBox.name(), heightPageContentPane, widthPageContentPane);
        vboxPage.setSlotSize(240, 180);

        vboxPage.add(new slotVboxDefaults(), "defaults");
        vboxPage.add(new slotVboxnodeHpos(), "nodeHpos");
        vboxPage.add(new slotVboxcenter(), "center");
        vboxPage.add(new slotVboxFillwidth(), "fillwidth");
        vboxPage.add(new slotVboxPadding(), "padding");
        vboxPage.add(new slotVboxSpacingCtor(), "spacing_Ctor");
        vboxPage.add(new slotVboxSpacing(), "spacing");
        vboxPage.add(new slotVboxSpacing2(), "spacing2");
        vboxPage.add(new slotVboxNodevbox(), "nodevpos");

        // ======== HBOX =================
        final PageWithSlots hboxPage = new PageWithSlots(Pages.HBox.name(), heightPageContentPane, widthPageContentPane);
        hboxPage.setSlotSize(210, 210);

        hboxPage.add(new slotHboxDefault(), "defaults");
        hboxPage.add(new slotHboxVposTOPHposLeading(), "VposTOPHposLeading");
        hboxPage.add(new slotHboxVposBOTTOMHposCenter(), "VposBOTTOMHposCenter");
        hboxPage.add(new slotHboxpadding(), "padding,nodeVPos.CENTER");
        hboxPage.add(new slotHboxspacing(), "spacing,nodeVpos.PAGE_END");
        hboxPage.add(new slotHboxspacingCtor(), "spacing_Ctor");
        hboxPage.add(new slotHboxnodevpos(), "nodevpos");

        // ============= BorderPane ====================
        final PageWithSlots borderPage = new PageWithSlots(Pages.BorderPane.name(), heightPageContentPane, widthPageContentPane);
        borderPage.setSlotSize(190, 190);

        borderPage.add(new slotBorderDefaults(), "defaults");
        borderPage.add(new slotBorderDefaults2(), "defaults2");
        borderPage.add(new slotBorderWayItWorks(), "wayItWorks");
        borderPage.add(new slotBorderchildWithLayout(), "childWithLayout");

        // ============= StackPane ====================
        final PageWithSlots stackPage = new PageWithSlots(Pages.StackPane.name(), heightPageContentPane, widthPageContentPane);
        stackPage.setSlotSize(140, 140);

        stackPage.add(new slotStackDefaults(), "defaults");
        stackPage.add(new slotStackPadding(), "padding");
        stackPage.add(new slotStacknodeVpos(), "nodeVpos");
        stackPage.add(new slotStacknodeHposRight(), "nodeHposRight");
        stackPage.add(new slotStacknodeHposLeft(), "nodeHposLeft");
        stackPage.add(new slotStacknodeHposTrailing(), "nodeHposTrailing");

        // ============= GridPane ====================
        final PageWithSlots gridPage = new PageWithSlots(Pages.GridPane.name(), heightPageContentPane, widthPageContentPane);
        gridPage.setSlotSize(160, 160);

        gridPage.add(new slotGriddefaults(), "defaults");
        gridPage.add(new slotGridHVgap(), "HVgap");
        gridPage.add(new slotGridpadding(), "padding");
        gridPage.add(new slotGridnodeVpos(), "nodeVpos");

        gridPage.add(new slotGridnodeHposRight(), "nodeHposRight");
        gridPage.add(new slotGridnodeHposCenter(), "nodeHposCenter");
        gridPage.add(new slotGridnodeHposTrailing(), "nodeHposTrailing");
        gridPage.add(new slotGridnodeColspan1(), "nodeColspan1");
        gridPage.add(new slotGridnodeColspan2(), "nodeColspan2");
        gridPage.add(new slotGridnodeColspan3(), "nodeColspan3");
        gridPage.add(new slotGridColumnInfo(), "GridColumnInfo");
        gridPage.add(new slotGridPercent1(), "GridPercent1");

        // ============= GridPane page2 ====================
        final PageWithSlots gridPage2 = new PageWithSlots(Pages.GridPane2.name(), heightPageContentPane, widthPageContentPane);
        gridPage2.setSlotSize(160, 160);

        gridPage2.add(new slotGridRowConstraint1(), "RowConstraint1");
        gridPage2.add(new slotGridRowConstraint2(), "RowConstraint2");

        // ============= FlowPane ====================
        final PageWithSlots flowPage = new PageWithSlots(Pages.FlowPane.name(), heightPageContentPane, widthPageContentPane);
        flowPage.setSlotSize(150, 150);

        flowPage.add(new slotFlowdefaults(), "defaults");
        flowPage.add(new slotFlowwrapLen(), "wrapLen");
        flowPage.add(new slotFlowpadding(), "padding");
        flowPage.add(new slotFlownodeVposBottom(), "nodeVposBottom");
        flowPage.add(new slotFlownodeVposTop(), "nodeVposTop");

        flowPage.add(new slotFlowGap5(), "Gap5");
        flowPage.add(new slotFlownodeHposRight(), " nodeHposRight");
        flowPage.add(new slotFlownodeHposRight2(), " nodeHposRight2");
        flowPage.add(new slotFlowvertical_1(), "vertical_1");
        flowPage.add(new slotFlowvertical_2(), "vertical_2");

        flowPage.add(new slotFlowhgapvgapCtor(), "hgap-vgap_Ctor");

        // ============= TilePane with long set of childs ====================
        final PageWithSlots tilePageLong = new PageWithSlots(Pages.TileLongSet.name(), heightPageContentPane, widthPageContentPane);
        tilePageLong.setSlotSize(170, 170);
        tilePageLong.setYGap(40);

        tilePageLong.add(new slotTiledefaults(new FillerWithAllNodes()), "defaults");
        tilePageLong.add(new slotTilegap(new FillerWithAllNodes()), "gap");
        tilePageLong.add(new slotTilegapCtor(new FillerWithAllNodes()), "gapCtor");
        tilePageLong.add(new slotTilegapCtor2(new FillerWithAllNodes()), "gapCtor2");

        tilePageLong.add(new slotTilepaddingVert(new FillerWithAllNodes()), "paddingVert");
        tilePageLong.add(new slotTileverticalCtor(new FillerWithAllNodes()), "vertical_Ctor");
        tilePageLong.add(new slotTileVpos(new FillerWithAllNodes()), "Vpos");
        tilePageLong.add(new slotTileHpos(new FillerWithAllNodes()), "Hpos");
        tilePageLong.add(new slotTilecenter(new FillerWithAllNodes()), "center");
        // ============= TilePane with short set of childs ====================
        final PageWithSlots tilePageShort = new PageWithSlots(Pages.TileShortSet.name(), heightPageContentPane, widthPageContentPane);
        tilePageShort.setSlotSize(170, 170);
        tilePageShort.setYGap(40);

        tilePageShort.add(new slotTiledefaults(new FillerWithNonResizeableNodes()), "defaults");
        tilePageShort.add(new slotTilegap(new FillerWithNonResizeableNodes()), "gap");
        tilePageShort.add(new slotTilegapCtor(new FillerWithNonResizeableNodes()), "gapCtor");
        tilePageShort.add(new slotTilegapCtor2(new FillerWithNonResizeableNodes()), "gapCtor2");

        tilePageShort.add(new slotTilepaddingVert(new FillerWithNonResizeableNodes()), "paddingVert");
        tilePageShort.add(new slotTileverticalCtor(new FillerWithNonResizeableNodes()), "vertical_Ctor");
        tilePageShort.add(new slotTileVpos(new FillerWithNonResizeableNodes()), "Vpos");
        tilePageShort.add(new slotTileHpos(new FillerWithNonResizeableNodes()), "Hpos");
        tilePageShort.add(new slotTilecenter(new FillerWithNonResizeableNodes()), "center");

        // ============= AnchorPane ====================
        final PageWithSlots anchorPage = new PageWithSlots(Pages.AnchorPane.name(), heightPageContentPane, widthPageContentPane);
        anchorPage.setSlotSize(140, 140);

        anchorPage.add(new slotAnchorDefaults(),"defaults");
        anchorPage.add(new slotAnchor2(),"anchors");


        // ========= root tests list ==============
        rootTestNode.add(vboxPage);
        rootTestNode.add(hboxPage);
        rootTestNode.add(borderPage);
        rootTestNode.add(stackPage);
        rootTestNode.add(gridPage);
        rootTestNode.add(gridPage2);
        rootTestNode.add(flowPage);
        rootTestNode.add(tilePageLong);
        rootTestNode.add(tilePageShort);
        rootTestNode.add(anchorPage);
        return rootTestNode;
    }

    public static void main(String args[]) {
        Utils.launch(Layout2App.class, args);
    }

}
